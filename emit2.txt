// MyRunnerConfigEmitter.java
// Generates a concrete class "MyRunnerConfig.java" that extends AbstractNamespacedConfig.
// Java 21+, no external deps.

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

public final class MyRunnerConfigEmitter {

  /* ===== Spec types (mirrors AbstractNamespacedConfig.Type) ===== */
  public enum Type {
    STRING, INT, LONG, DOUBLE, BOOLEAN,
    STRING_LIST, INT_LIST, LONG_LIST, DOUBLE_LIST, BOOLEAN_LIST
  }

  public static final class ParamSpec {
    public final String name;           // e.g., "batchSize"
    public final Type type;
    public final String defaultValue;   // code literal or CSV for lists; null = no default
    public final boolean mandatory;     // if true and no default, validated (subset: only when used)
    public final List<String> aliases;  // additional CLI keys; kebab will be auto-added based on name

    public ParamSpec(String name, Type type, String defaultValue, boolean mandatory, List<String> aliases) {
      this.name = name; this.type = type; this.defaultValue = defaultValue;
      this.mandatory = mandatory; this.aliases = aliases == null ? List.of() : List.copyOf(aliases);
    }
    public ParamSpec(String name, Type type, String defaultValue, boolean mandatory, String... aliases) {
      this(name, type, defaultValue, mandatory, Arrays.asList(aliases));
    }
  }

  public static final class SubsetSpec {
    public final String prefix;     // CLI key prefix (e.g., "amps")
    public final String className;  // public inner class & getter base name (e.g., "SourceAmps")
    public final List<ParamSpec> params;

    public SubsetSpec(String prefix, String className, List<ParamSpec> params) {
      this.prefix = prefix; this.className = className; this.params = List.copyOf(params);
    }
  }

  /* ===== Generator ===== */
  public static String generate(
      String packageName,                  // e.g., "com.example"
      String className,                    // e.g., "MyRunnerConfig"
      List<ParamSpec> topParams,
      List<SubsetSpec> subsets
  ) {
    String pkg = (packageName == null || packageName.isBlank()) ? "" : "package " + packageName + ";\n\n";
    StringBuilder sb = new StringBuilder(90_000);

    sb.append(pkg);
    sb.append("// Auto-generated by MyRunnerConfigEmitter\n");
    sb.append("import java.util.*;\n\n");
    sb.append("public final class ").append(className)
      .append(" extends AbstractNamespacedConfig<").append(className).append(".Builder, ").append(className).append(".Config> {\n\n");

    /* -------- Defaults -------- */
    sb.append("  /* ===== Defaults ===== */\n");
    sb.append("  static final class Defaults {\n");
    // top-level defaults
    for (ParamSpec p : topParams) {
      sb.append("    static final ").append(javaType(p.type)).append(" ").append(p.name)
        .append(" = ").append(defaultLiteral(p)).append(";\n");
    }
    // subset defaults
    for (SubsetSpec s : subsets) {
      for (ParamSpec p : s.params) {
        sb.append("    static final ").append(javaType(p.type)).append(" ")
          .append(s.prefix).append("_").append(p.name)
          .append(" = ").append(defaultLiteral(p)).append(";\n");
      }
    }
    sb.append("  }\n\n");

    /* -------- Subset public classes + builders -------- */
    for (SubsetSpec s : subsets) {
      // public immutable subset
      sb.append("  public static final class ").append(s.className).append(" {\n");
      for (ParamSpec p : s.params) {
        sb.append("    private final ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
      }
      sb.append("    private ").append(s.className).append("(");
      for (int i = 0; i < s.params.size(); i++) {
        if (i > 0) sb.append(", ");
        ParamSpec p = s.params.get(i);
        sb.append(javaType(p.type)).append(" ").append(p.name);
      }
      sb.append(") {\n");
      for (ParamSpec p : s.params) {
        sb.append("      this.").append(p.name).append(" = ").append(p.name).append(";\n");
      }
      sb.append("    }\n");
      for (ParamSpec p : s.params) {
        sb.append("    public ").append(javaType(p.type)).append(" get").append(capitalize(p.name)).append("() { return ").append(p.name).append("; }\n");
      }
      sb.append("    @Override public String toString() {\n");
      sb.append("      StringBuilder sb = new StringBuilder();\n");
      sb.append("      sb.append(\"").append(s.className).append("{\\n\");\n");
      for (ParamSpec p : s.params) {
        sb.append("      sb.append(\"  ").append(p.name).append("=\").append(String.valueOf(").append(p.name)
          .append(")).append(\"  (default=\").append(String.valueOf(Defaults.").append(s.prefix).append("_").append(p.name)
          .append(")).append(\")\\n\");\n");
      }
      sb.append("      sb.append(\"}\"); return sb.toString(); }\n");
      sb.append("  }\n\n");

      // subset builder (validate only if used) — now PUBLIC and VISIBLE
      sb.append("  public static final class ").append(s.className).append("Builder {\n");
      sb.append("    boolean used = false;\n");
      for (ParamSpec p : s.params) {
        if (p.defaultValue == null) {
          if (isList(p.type)) {
            sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(" = java.util.List.of();\n");
          } else if (p.type == Type.STRING) {
            sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
          } else {
            sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(" = ").append(javaDefault(p.type)).append(";\n");
          }
        } else {
          sb.append("    ").append(javaType(p.type)).append(" ").append(p.name)
            .append(" = Defaults.").append(s.prefix).append("_").append(p.name).append(";\n");
        }
      }
      for (ParamSpec p : s.params) {
        sb.append("    public ").append(s.className).append("Builder with").append(capitalize(p.name)).append("(")
          .append(javaType(p.type)).append(" v) { this.").append(p.name).append(" = v; used = true; return this; }\n");
      }
      sb.append("    void validate() {\n");
      sb.append("      if (!used) return;\n");
      for (ParamSpec p : s.params) {
        if (p.mandatory && p.defaultValue == null) {
          sb.append("      if (");
          if (p.type == Type.STRING) {
            sb.append(p.name).append(" == null || ").append(p.name).append(".isBlank()");
          } else if (isList(p.type)) {
            sb.append(p.name).append(" == null || ").append(p.name).append(".isEmpty()");
          } else {
            sb.append("false");
          }
          sb.append(") throw new IllegalArgumentException(\"Missing mandatory parameter: ").append(s.prefix).append(".").append(p.name).append("\");\n");
        }
      }
      sb.append("    }\n");
      sb.append("    ").append(s.className).append(" build() { validate(); return new ").append(s.className).append("(");
      for (int i = 0; i < s.params.size(); i++) {
        if (i > 0) sb.append(", ");
        sb.append(s.params.get(i).name);
      }
      sb.append("); }\n");
      sb.append("  }\n\n");
    }

    /* -------- Top-level immutable Config -------- */
    sb.append("  public static final class Config {\n");
    for (ParamSpec p : topParams) {
      sb.append("    private final ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
    }
    for (SubsetSpec s : subsets) {
      sb.append("    private final ").append(s.className).append(" ").append(s.prefix).append(";\n");
    }
    sb.append("    private Config(");
    {
      boolean first = true;
      for (ParamSpec p : topParams) {
        if (!first) sb.append(", "); first = false;
        sb.append(javaType(p.type)).append(" ").append(p.name);
      }
      for (SubsetSpec s : subsets) {
        if (!first) sb.append(", "); first = false;
        sb.append(s.className).append(" ").append(s.prefix);
      }
    }
    sb.append(") {\n");
    for (ParamSpec p : topParams) {
      if (isList(p.type)) {
        sb.append("      this.").append(p.name).append(" = java.util.List.copyOf(").append(p.name).append(");\n");
      } else {
        sb.append("      this.").append(p.name).append(" = ").append(p.name).append(";\n");
      }
    }
    for (SubsetSpec s : subsets) {
      sb.append("      this.").append(s.prefix).append(" = ").append(s.prefix).append(";\n");
    }
    sb.append("    }\n");
    for (ParamSpec p : topParams) {
      sb.append("    public ").append(javaType(p.type)).append(" get").append(capitalize(p.name)).append("() { return ").append(p.name).append("; }\n");
    }
    for (SubsetSpec s : subsets) {
      sb.append("    public ").append(s.className).append(" get").append(s.className).append("() { return ").append(s.prefix).append("; }\n");
    }
    sb.append("    @Override public String toString() {\n");
    sb.append("      StringBuilder sb = new StringBuilder();\n");
    sb.append("      sb.append(\"").append(className).append(".Config{\\n\");\n");
    for (ParamSpec p : topParams) {
      sb.append("      sb.append(\"  ").append(p.name).append("=\").append(String.valueOf(").append(p.name)
        .append(")).append(\"  (default=\").append(String.valueOf(Defaults.").append(p.name).append(")).append(\")\\n\");\n");
    }
    for (SubsetSpec s : subsets) {
      sb.append("      sb.append(\"  ").append(s.className).append("=\\n\").append(").append(s.prefix).append(").append(\"\\n\");\n");
    }
    sb.append("      sb.append(\"}\"); return sb.toString(); }\n");
    sb.append("  }\n\n");

    /* -------- Builder -------- */
    sb.append("  public static final class Builder {\n");
    for (ParamSpec p : topParams) {
      if (p.defaultValue == null) {
        if (isList(p.type)) {
          sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(" = java.util.List.of();\n");
        } else if (p.type == Type.STRING) {
          sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
        } else {
          sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(" = ").append(javaDefault(p.type)).append(";\n");
        }
      } else {
        sb.append("    ").append(javaType(p.type)).append(" ").append(p.name)
          .append(" = Defaults.").append(p.name).append(";\n");
      }
    }
    for (SubsetSpec s : subsets) {
      sb.append("    final ").append(s.className).append("Builder ").append(s.prefix).append("Builder = new ").append(s.className).append("Builder();\n");
    }
    // withXxx setters
    for (ParamSpec p : topParams) {
      sb.append("    public Builder with").append(capitalize(p.name)).append("(").append(javaType(p.type)).append(" v) { this.")
        .append(p.name).append(" = ");
      if (isList(p.type)) sb.append("java.util.List.copyOf(v)"); else sb.append("v");
      sb.append("; return this; }\n");
    }
    // subset builder accessors — getter-style & visible
    for (SubsetSpec s : subsets) {
      sb.append("    public ").append(s.className).append("Builder getConfig").append(s.className).append("() { return ").append(s.prefix).append("Builder; }\n");
    }
    // validate()
    sb.append("    Builder validate() {\n");
    for (ParamSpec p : topParams) {
      if (p.mandatory && p.defaultValue == null) {
        sb.append("      if (");
        if (p.type == Type.STRING) {
          sb.append(p.name).append(" == null || ").append(p.name).append(".isBlank()");
        } else if (isList(p.type)) {
          sb.append(p.name).append(" == null || ").append(p.name).append(".isEmpty()");
        } else {
          sb.append("false");
        }
        sb.append(") throw new IllegalArgumentException(\"Missing mandatory parameter: ").append(p.name).append("\");\n");
      }
    }
    for (SubsetSpec s : subsets) {
      sb.append("      ").append(s.prefix).append("Builder.validate();\n");
    }
    sb.append("      return this; }\n");
    // build()
    sb.append("    public Config build() {\n");
    sb.append("      validate();\n");
    for (SubsetSpec s : subsets) {
      sb.append("      ").append(s.className).append(" _").append(s.prefix).append(" = ").append(s.prefix).append("Builder.build();\n");
    }
    sb.append("      return new Config(");
    {
      boolean first = true;
      for (ParamSpec p : topParams) {
        if (!first) sb.append(", "); first = false;
        sb.append(p.name);
      }
      for (SubsetSpec s : subsets) {
        if (!first) sb.append(", "); first = false;
        sb.append("_").append(s.prefix);
      }
    }
    sb.append(");\n");
    sb.append("    }\n");
    sb.append("  }\n\n");

    sb.append("  public static Builder builder() { return new Builder(); }\n\n");

    /* -------- Abstract base overrides -------- */
    sb.append("  @Override protected Builder newBuilder() { return builder(); }\n");
    sb.append("  @Override protected Config build(Builder builder) { return builder.build(); }\n\n");

    // topAliases()
    sb.append("  @Override protected Map<String, List<String>> topAliases() {\n");
    sb.append("    Map<String, List<String>> m = new LinkedHashMap<>();\n");
    for (ParamSpec p : topParams) {
      List<String> all = withKebab(p.name, p.aliases);
      sb.append("    m.put(\"").append(p.name).append("\", List.of(").append(joinQuoted(all)).appen
