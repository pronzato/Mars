// === Drop-in: pretty, auto-wrapped, console-width aware help table ===
public final void printHelp() {
  final int MAX_COL_WIDTH  = 48;                 // cap any single column
  final int CONSOLE_WIDTH  = detectConsoleWidth(100);  // auto-detect, fallback to 100

  // Top-level table
  var topRows = new ArrayList<String[]>();
  for (ParamInfo p : topParamsInfo()) {
    topRows.add(new String[]{
        "--" + toKebab(p.name),
        p.aliases.isEmpty() ? "" : String.join(", ", p.aliases),
        typeNameForHelp(p.type),
        String.valueOf(p.defaultValue),
        p.mandatory ? "yes" : ""
    });
  }
  renderTableAutoCompact(
      "Top-level options",
      new String[]{"Option", "Aliases", "Type", "Default", "Req"},
      topRows,
      MAX_COL_WIDTH,
      CONSOLE_WIDTH
  );

  // One table per subset
  for (SubsetInfo s : subsetsInfo()) {
    var subsetRows = new ArrayList<String[]>();
    for (ParamInfo p : s.params) {
      subsetRows.add(new String[]{
          "--" + s.prefix + "." + toKebab(p.name),
          p.aliases.isEmpty() ? "" : String.join(", ", p.aliases),
          typeNameForHelp(p.type),
          String.valueOf(p.defaultValue),
          p.mandatory ? "yes (if used)" : ""
      });
    }
    renderTableAutoCompact(
        "Subset: " + s.className + "  (use --" + s.prefix + ".<field>)",
        new String[]{"Option", "Aliases", "Type", "Default", "Req"},
        subsetRows,
        MAX_COL_WIDTH,
        CONSOLE_WIDTH
    );
  }
}

/* ===== Helpers (no external deps) ===== */

// Try to detect terminal width from env or system properties; fallback if unknown.
private static int detectConsoleWidth(int fallback) {
  try {
    String cols = System.getenv("COLUMNS");
    if (cols != null && !cols.isBlank()) {
      int v = Integer.parseInt(cols.trim());
      if (v >= 40) return v; // sanity floor
    }
  } catch (Exception ignored) {}
  try {
    String prop = System.getProperty("terminal.columns");
    if (prop != null && !prop.isBlank()) {
      int v = Integer.parseInt(prop.trim());
      if (v >= 40) return v;
    }
  } catch (Exception ignored) {}
  // Could add reflective detection for libraries (JLine, etc.) if presentâ€”keeping deps free.
  return fallback;
}

// Computes auto widths per column, then shrinks to fit totalWidth if needed.
private static void renderTableAutoCompact(
    String title,
    String[] headers,
    java.util.List<String[]> rows,
    int maxColWidth,
    int totalWidth
) {
  int cols = headers.length;

  // Longest token per column (including header), used to preserve whole words where possible
  int[] tokenMax = new int[cols];
  for (int c = 0; c < cols; c++) tokenMax[c] = Math.min(maxColWidth, longestToken(headers[c]));
  for (String[] r : rows) {
    for (int c = 0; c < cols; c++) {
      int m = longestToken(r[c] == null ? "" : r[c]);
      tokenMax[c] = Math.min(maxColWidth, Math.max(tokenMax[c], m));
    }
  }

  // Natural width per column = max(header length, tokenMax), capped
  int[] widths = new int[cols];
  for (int c = 0; c < cols; c++) {
    widths[c] = Math.min(maxColWidth, Math.max(headers[c].length(), tokenMax[c]));
  }

  // Visual row width = 1 + sum(widths) + 3*cols  (| + per-col " sp + data + sp + | ")
  int visuals = 1 + sum(widths) + 3 * cols;

  // If too wide, try to shrink while preserving token boundaries first.
  if (visuals > totalWidth) {
    shrinkWidths(widths, tokenMax, totalWidth, /*respectTokens=*/true);
    visuals = 1 + sum(widths) + 3 * cols;
  }

  // If still too wide, allow hard cuts below tokens down to a readable minimum.
  if (visuals > totalWidth) {
    int[] minAbs = new int[cols];
    for (int c = 0; c < cols; c++) {
      // Absolute floor: at least header length (readable) and at least 6 chars
      minAbs[c] = Math.min(widths[c], Math.max(6, headers[c].length()));
    }
    shrinkWidths(widths, minAbs, totalWidth, /*respectTokens=*/false);
  }

  String hbar = hbar(widths);
  System.out.println();
  System.out.println(title);
  System.out.println(hbar);
  System.out.println(renderRow(headers, widths));
  System.out.println(hbar);

  // Wrap & render each row
  for (String[] r : rows) {
    java.util.List<java.util.List<String>> wrappedCols = new ArrayList<>(cols);
    int maxLines = 1;
    for (int c = 0; c < cols; c++) {
      java.util.List<String> lines = wrapCell(r[c] == null ? "" : r[c], widths[c]);
      wrappedCols.add(lines);
      maxLines = Math.max(maxLines, lines.size());
    }
    for (int line = 0; line < maxLines; line++) {
      String[] slice = new String[cols];
      for (int c = 0; c < cols; c++) {
        java.util.List<String> lines = wrappedCols.get(c);
        slice[c] = line < lines.size() ? lines.get(line) : "";
      }
      System.out.println(renderRow(slice, widths));
    }
  }
  System.out.println(hbar);
}

// Proportionally shrink columns down towards "minWidth[c]" until total fits.
// If respectTokens == true, minWidth is tokenMax; else it's absolute floors.
private static void shrinkWidths(int[] widths, int[] minWidth, int totalWidth, boolean respectTokens) {
  final int cols = widths.length;
  final int fixedOverhead = 1 + 3 * cols; // row bars/spaces
  int sum = sum(widths);
  int targetSum = Math.max(cols, totalWidth - fixedOverhead);
  if (sum <= targetSum) return;

  // Iteratively reduce: proportional to available shrink capacity.
  int remaining = sum - targetSum;
  int guard = 0;
  while (remaining > 0 && guard++ < 1000) {
    int totalCap = 0;
    for (int c = 0; c < cols; c++) totalCap += Math.max(0, widths[c] - minWidth[c]);
    if (totalCap <= 0) break; // cannot shrink further

    int shavedThisRound = 0;
    for (int c = 0; c < cols; c++) {
      int cap = Math.max(0, widths[c] - minWidth[c]);
      if (cap == 0) continue;
      int share = Math.max(1, (int)Math.floor((remaining * (double)cap) / totalCap));
      int take = Math.min(share, cap);
      widths[c] -= take;
      shavedThisRound += take;
    }
    remaining -= shavedThisRound;

    // If floors prevented progress, shave 1 char from the widest eligible col.
    if (shavedThisRound == 0) {
      int widest = -1, idx = -1;
      for (int c = 0; c < cols; c++) {
        if (widths[c] > minWidth[c] && widths[c] > widest) { widest = widths[c]; idx = c; }
      }
      if (idx < 0) break;
      widths[idx] -= 1;
      remaining -= 1;
    }
  }

  // If still too wide and we were respecting tokens, caller will re-invoke allowing hard cuts.
  if (respectTokens) {
    int sumW = sum(widths);
    if (sumW + fixedOverhead > totalWidth) {
      // no-op; caller follows up with hard-cut shrink
    }
  }
}

private static int sum(int[] a) { int s = 0; for (int v : a) s += v; return s; }

private static String hbar(int[] widths) {
  StringBuilder sb = new StringBuilder();
  sb.append('+');
  for (int w : widths) sb.append("-".repeat(w + 2)).append('+');
  return sb.toString();
}

private static String renderRow(String[] cells, int[] widths) {
  StringBuilder sb = new StringBuilder();
  sb.append('|');
  for (int c = 0; c < widths.length; c++) {
    String cell = cells[c] == null ? "" : cells[c];
    sb.append(' ').append(padRight(cell, widths[c])).append(' ').append('|');
  }
  return sb.toString();
}

private static String padRight(String s, int w) {
  if (s == null) s = "";
  int pad = w - s.length();
  if (pad <= 0) return s;
  return s + " ".repeat(pad);
}

private static java.util.List<String> wrapCell(String text, int width) {
  if (width <= 1) return java.util.List.of(text == null ? "" : text);
  if (text == null || text.isBlank()) return java.util.List.of("");

  String[] hard = text.split("\\R");
  java.util.List<String> out = new ArrayList<>();
  for (String seg : hard) out.addAll(wrapSegment(seg, width));
  return out;
}

private static java.util.List<String> wrapSegment(String s, int width) {
  java.util.List<String> lines = new ArrayList<>();
  int i = 0, n = s.length();
  while (i < n) {
    int end = Math.min(i + width, n);

    // Prefer breaking on whitespace or commas inside window
    int breakPos = -1;
    for (int j = end - 1; j >= i; j--) {
      char ch = s.charAt(j);
      if (Character.isWhitespace(ch) || ch == ',') { breakPos = j; break; }
    }
    if (breakPos < i) breakPos = end; // hard cut

    String chunk = s.substring(i, breakPos).trim();
    if (chunk.isEmpty() && breakPos < n) {
      // Avoid empty visual line if leading space; take 1 char
      chunk = String.valueOf(s.charAt(i));
      breakPos = i + 1;
    }
    lines.add(chunk);

    i = breakPos;
    while (i < n && (Character.isWhitespace(s.charAt(i)) || s.charAt(i) == ',')) i++;
  }
  return lines;
}

private static int longestToken(String s) {
  if (s == null || s.isEmpty()) return 0;
  int max = 0, cur = 0;
  for (int i = 0; i < s.length(); i++) {
    char ch = s.charAt(i);
    if (Character.isWhitespace(ch) || ch == ',' || ch == ';') {
      if (cur > max) max = cur;
      cur = 0;
    } else {
      cur++;
    }
  }
  return Math.max(max, cur);
}




















