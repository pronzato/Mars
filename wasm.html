<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DuckDB + WASM Capability Check</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
      padding: 20px;
    }
    h1, h2 {
      color: #6cf;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 1rem;
    }
    th, td {
      border: 1px solid #444;
      padding: 6px 8px;
      font-size: 0.9rem;
      vertical-align: top;
    }
    th {
      background: #222;
    }
    tr:nth-child(even) td {
      background: #181818;
    }
    .status-pass {
      color: #4caf50;
      font-weight: bold;
    }
    .status-fail {
      color: #f44336;
      font-weight: bold;
    }
    .status-warn {
      color: #ff9800;
      font-weight: bold;
    }
    .monospace {
      font-family: "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.85rem;
      white-space: pre-wrap;
      word-break: break-word;
    }
    #log {
      margin-top: 1.5rem;
      padding: 10px;
      border: 1px solid #333;
      background: #050505;
      max-height: 300px;
      overflow: auto;
      font-size: 0.8rem;
    }
    #iframeTestContainer {
      display: none; /* hidden, we don't need to show it */
    }
  </style>
</head>
<body>
  <h1>DuckDB + WASM Capability Check</h1>
  <p>
    This page runs a series of tests in your current browser to see whether
    key features required for a DuckDB + WebAssembly integration (and some
    Fabric Studio UI patterns like iframes) are available.
  </p>

  <h2>Results</h2>
  <table id="resultsTable">
    <thead>
      <tr>
        <th style="width: 20%">Test</th>
        <th style="width: 10%">Status</th>
        <th>Details</th>
      </tr>
    </thead>
    <tbody id="resultsBody">
      <!-- Filled by JS -->
    </tbody>
  </table>

  <h2>Debug Log</h2>
  <div id="log" class="monospace"></div>

  <div id="iframeTestContainer"></div>

  <script type="module">
    // === CONFIGURATION =======================================================
    // If your org blocks public CDNs, you can later change this to an internal
    // URL where you host @duckdb/duckdb-wasm as an ESM bundle.
    const CONFIG = {
      duckdbEsmUrl: "https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm"
      // You can pin a specific version above or use @latest, depending on policy.
    };

    // === UTILITIES ============================================================
    const resultsBody = document.getElementById("resultsBody");
    const logDiv = document.getElementById("log");

    function appendLog(message, error = false) {
      const time = new Date().toISOString();
      const line = `[${time}] ${message}`;
      const el = document.createElement("div");
      el.textContent = line;
      if (error) {
        el.style.color = "#f44336";
      }
      logDiv.appendChild(el);
      logDiv.scrollTop = logDiv.scrollHeight;
      console[error ? "error" : "log"](line);
    }

    function addResult(name, status, details) {
      const tr = document.createElement("tr");

      const tdName = document.createElement("td");
      tdName.textContent = name;

      const tdStatus = document.createElement("td");
      const spanStatus = document.createElement("span");
      spanStatus.textContent = status.toUpperCase();
      if (status === "pass") spanStatus.className = "status-pass";
      else if (status === "fail") spanStatus.className = "status-fail";
      else spanStatus.className = "status-warn";
      tdStatus.appendChild(spanStatus);

      const tdDetails = document.createElement("td");
      tdDetails.className = "monospace";
      tdDetails.textContent = typeof details === "string" ? details : JSON.stringify(details, null, 2);

      tr.appendChild(tdName);
      tr.appendChild(tdStatus);
      tr.appendChild(tdDetails);

      resultsBody.appendChild(tr);
    }

    function summarizeError(err) {
      if (!err) return "Unknown error";
      if (typeof err === "string") return err;
      if (err.message) return err.message;
      try {
        return JSON.stringify(err);
      } catch {
        return String(err);
      }
    }

    // === TESTS ===============================================================

    async function testEnvironmentBasics() {
      try {
        const ua = navigator.userAgent;
        const info = {
          userAgent: ua,
          platform: navigator.platform,
          language: navigator.language,
        };
        addResult("Environment", "pass", info);
        appendLog("Environment detected: " + ua);
      } catch (err) {
        addResult("Environment", "fail", summarizeError(err));
        appendLog("Environment detection failed: " + summarizeError(err), true);
      }
    }

    async function testWebAssemblyBasic() {
      try {
        const hasWasm = typeof WebAssembly === "object";
        if (!hasWasm) {
          addResult("WebAssembly basic", "fail", "WebAssembly object is not available on window.");
          appendLog("WebAssembly is NOT available.");
          return;
        }

        // Minimal WASM module: (module)
        const bytes = new Uint8Array([
          0x00,0x61,0x73,0x6d, // '\0asm'
          0x01,0x00,0x00,0x00  // version 1
        ]);
        await WebAssembly.instantiate(bytes.buffer);
        addResult("WebAssembly basic", "pass", "WebAssembly.instantiate() succeeded with a minimal module.");
        appendLog("WebAssembly.instantiate() succeeded.");
      } catch (err) {
        addResult("WebAssembly basic", "fail", summarizeError(err));
        appendLog("WebAssembly basic test failed: " + summarizeError(err), true);
      }
    }

    async function testWorkersAndSharedArrayBuffer() {
      try {
        const hasWorker = typeof Worker === "function";
        const hasSharedArrayBuffer = typeof SharedArrayBuffer === "function";
        const details = {
          Worker: hasWorker,
          SharedArrayBuffer: hasSharedArrayBuffer,
          note: "SharedArrayBuffer typically requires cross-origin isolation (COOP/COEP)."
        };

        let status = "pass";
        if (!hasWorker) status = "fail";
        else if (!hasSharedArrayBuffer) status = "warn";

        addResult("Workers / SharedArrayBuffer", status, details);
        appendLog("Workers / SharedArrayBuffer: " + JSON.stringify(details));
      } catch (err) {
        addResult("Workers / SharedArrayBuffer", "fail", summarizeError(err));
        appendLog("Workers / SharedArrayBuffer test failed: " + summarizeError(err), true);
      }
    }

    async function testIframeBasic() {
      try {
        const container = document.getElementById("iframeTestContainer");
        const iframe = document.createElement("iframe");
        iframe.style.width = "0";
        iframe.style.height = "0";
        iframe.style.border = "0";
        iframe.src = "about:blank";

        const result = {
          created: false,
          loaded: false,
          sameOriginAccessible: false
        };

        result.created = true;

        const loadPromise = new Promise((resolve) => {
          iframe.onload = () => {
            result.loaded = true;
            try {
              // This will only be accessible if policy allows about:blank iframes
              const win = iframe.contentWindow;
              result.sameOriginAccessible = !!(win && win.document);
            } catch (err) {
              result.sameOriginAccessible = false;
            }
            resolve();
          };
          iframe.onerror = () => {
            result.loaded = false;
            resolve();
          };
        });

        container.appendChild(iframe);
        await loadPromise;

        let status = "pass";
        if (!result.loaded) status = "fail";

        addResult("Iframe basic", status, result);
        appendLog("Iframe basic test result: " + JSON.stringify(result));
      } catch (err) {
        addResult("Iframe basic", "fail", summarizeError(err));
        appendLog("Iframe basic test failed: " + summarizeError(err), true);
      }
    }

    async function testDuckDBImport() {
      try {
        appendLog("Attempting to import DuckDB WASM from: " + CONFIG.duckdbEsmUrl);
        const duckdb = await import(CONFIG.duckdbEsmUrl);
        const keys = Object.keys(duckdb);
        const summary = {
          imported: true,
          exportsSample: keys.slice(0, 10)
        };
        addResult("DuckDB ESM import", "pass", summary);
        appendLog("DuckDB ESM import succeeded. Export keys: " + keys.join(", "));
        return duckdb;
      } catch (err) {
        addResult("DuckDB ESM import", "fail", summarizeError(err));
        appendLog("DuckDB ESM import FAILED: " + summarizeError(err), true);
        return null;
      }
    }

    async function testDuckDBInstantiateAndQuery(duckdb) {
      if (!duckdb) {
        addResult("DuckDB instantiate + SELECT 42", "fail", "DuckDB ESM import failed, cannot instantiate.");
        return;
      }

      // We'll try to pick a bundle that works in this environment.
      try {
        appendLog("Selecting DuckDB WASM bundle...");
        const bundles = duckdb.getJsDelivrBundles
          ? duckdb.getJsDelivrBundles()
          : (duckdb.getBundles ? duckdb.getBundles() : null);

        if (!bundles || bundles.length === 0) {
          addResult("DuckDB instantiate + SELECT 42", "fail", "No bundles returned by getJsDelivrBundles/getBundles().");
          appendLog("No DuckDB bundles available.", true);
          return;
        }

        const bundle = await duckdb.selectBundle(bundles);
        appendLog("Selected DuckDB bundle: " + JSON.stringify(bundle));

        const logger = new duckdb.ConsoleLogger();
        const worker = new Worker(bundle.mainWorker);
        const db = new duckdb.AsyncDuckDB(logger, worker);

        await db.instantiate(bundle.mainModule, bundle.pthreadWorker);

        const conn = await db.connect();
        const result = await conn.query("SELECT 42 AS answer");
        const rows = result.toArray ? result.toArray() : result;

        let answerValue = null;
        if (rows && rows.length > 0) {
          const row = rows[0];
          answerValue = row.answer ?? row[0];
        }

        const details = {
          bundle,
          result: rows,
          answer: answerValue
        };

        const status = (answerValue === 42) ? "pass" : "warn";
        addResult("DuckDB instantiate + SELECT 42", status, details);
        appendLog("DuckDB SELECT 42 result: " + JSON.stringify(details));
      } catch (err) {
        addResult("DuckDB instantiate + SELECT 42", "fail", summarizeError(err));
        appendLog("DuckDB instantiate + SELECT 42 FAILED: " + summarizeError(err), true);
      }
    }

    // === MAIN ================================================================
    (async function main() {
      appendLog("Starting DuckDB + WASM capability checks...");

      await testEnvironmentBasics();
      await testWebAssemblyBasic();
      await testWorkersAndSharedArrayBuffer();
      await testIframeBasic();

      const duckdb = await testDuckDBImport();
      await testDuckDBInstantiateAndQuery(duckdb);

      appendLog("All tests completed.");
    })();
  </script>
</body>
</html>
