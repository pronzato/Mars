{toc}

h1. Metadata, Schemas, and Configuration


h2. A governed configuration platform
Fabric provides a first-class metadata and configuration platform for managing datasets, streams, services, and schemas.

Configuration is treated as data:
* Versioned
* Auditable
* Time-aware
* Governed by entitlements

Rather than embedding configuration in code or distributing it across systems, Fabric centralizes metadata and configuration in a controlled platform layer.

h2. What is managed
Fabric manages metadata and configuration for core platform resources, including:

* Datasets and dataset schemas
* Streams and stream metadata
* Services and service endpoints
* Feeds and ingest definitions
* Materialized datasets and derived views
* Environment- and region-specific settings

All metadata is identified canonically and referenced consistently across the platform.

h2. Layered and composable configuration
Fabric supports layered configuration models.

* Base configuration defines default behavior.
* Overlay layers can refine or override specific fields.
* Layers can be composed to produce an effective configuration.

This allows teams to:
* Share common defaults
* Customize behavior per environment or deployment
* Avoid duplication across configurations

h2. Effective time and safe rollout
Configuration changes in Fabric are time-aware.

* Changes can be defined with an effective timestamp.
* Future-dated configuration enables controlled rollout.
* Historical configurations remain queryable.

This allows configuration changes to be introduced safely without requiring coordinated restarts or manual cutovers.

h2. Auditability and rollback
All metadata changes are auditable.

* Every change is recorded with author, timestamp, and reason.
* Previous versions remain accessible.
* Rollback is explicit and controlled.

This enables teams to:
* Understand how a system reached its current state
* Revert changes safely
* Satisfy audit and compliance requirements

h2. Schema management and evolution
Fabric manages schemas as first-class metadata.

* Schemas are versioned and validated.
* Compatibility rules can be enforced on change.
* Schema evolution is governed, not ad hoc.

Schemas are used consistently across ingest, query, streaming, and service interfaces.

h2. Client APIs, subscriptions, and code generation
Metadata and configuration are accessible through client APIs and can be consumed dynamically.

* Applications can query effective configuration programmatically.
* Clients can subscribe to configuration updates and react to changes.
* Configuration is resolved centrally, not reimplemented in clients.
* Strongly-typed models can be generated from schema definitions.

This allows applications to treat configuration as a live, typed input rather than static files or environment variables.

h2. Example: subscribing to dataset configuration
A client can subscribe to configuration updates using a strongly-typed POJO.

h3. Configuration POJO (example)
{code:language=java}
public final class MoviesDatasetConfig {
  public String dataset;
  public String storageLocation;
  public String format;
}
{code}

h3. Subscribe and react to config changes
{code:language=java}
// Client application — subscribe to dataset metadata
Fabric.Session session = Fabric.newSession()
    .withGroup("media")
    .withName("movies-app")
    .build();

session.start();

session.meta().subscribe(
    "dataset:movies",
    MoviesDatasetConfig.class,
    config -> {
      System.out.println("Dataset: " + config.dataset);
      System.out.println("Format: " + config.format);
      System.out.println("Storage: " + config.storageLocation);
    }
);
{code}

When configuration changes become effective, the callback is invoked automatically with the resolved configuration.

h3. Example logged output
{code}
Dataset: movies
Format: parquet
Storage: s3://prod-media-datasets/movies
{code}

This allows applications to:
* React to configuration changes without restart
* Maintain a single source of truth
* Safely evolve behavior over time

h2. Example: dataset metadata (movies)
The following simplified example shows how a dataset might be defined:

{code:language=json}
{
  "dataset": "movies",
  "owner": "group:media",
  "schema": "movies_v1",
  "storage": {
    "format": "parquet",
    "location": "s3://media-datasets/movies"
  },
  "governance": {
    "readers": ["group:analysts"],
    "writers": ["app:movie-ingest"]
  }
}
{code}

This metadata defines:
* A canonical dataset identity
* Ownership and governance
* Storage location and format
* A schema reference used across the platform

h2. Example: layered configuration override
A production overlay might refine behavior without redefining the base:

{code:language=json}
{
  "dataset": "movies",
  "layer": "prod",
  "overrides": {
    "storage": {
      "location": "s3://prod-media-datasets/movies"
    }
  },
  "effective_from": "2026-03-01T00:00:00Z"
}
{code}

At runtime, Fabric resolves the effective configuration by combining base and overlay layers.

h2. Example: schema definition (movies)
Schemas are defined explicitly and versioned:

{code:language=json}
{
  "schema": "movies_v1",
  "fields": [
    { "name": "movie_id", "type": "string" },
    { "name": "title", "type": "string" },
    { "name": "release_year", "type": "int" },
    { "name": "genre", "type": "string" },
    { "name": "rating", "type": "double" }
  ]
}
{code}

Schema compatibility rules ensure safe evolution as datasets change.

h2. Why this matters
Fabric’s metadata and configuration model enables:

* Safe, audited change management
* Clear separation between code and configuration
* Live, reactive configuration for applications
* Consistent behavior across environments
* Strong governance without sacrificing flexibility

For organizations managing complex data and service estates, this provides a controlled foundation for scaling safely.
