{toc}


h2. A single governance model
Fabric applies governance as a first-class platform concern rather than an afterthought.

A single entitlement model is used consistently across:
* Datasets
* Streams
* Services
* Queries and APIs

The same access rules apply regardless of *how* something is accessed — whether through a query, a stream subscription, or a service call.

Fabric enforces governance at the platform boundary, removing the need for each transport, engine, or service to implement its own authorization logic.

h2. Entitlements foundation

Fabric’s entitlement model is inspired by *Zanzibar*, an authorization system designed and described by Google.

Zanzibar is not a third-party product or service. It is a *well-established architectural pattern* for large-scale, fine-grained authorization, based on representing access control as relationships between subjects and resources and evaluating those relationships dynamically at request time.

Google uses this model internally to enforce access control across many of its largest systems, including user data, services, and internal APIs, at global scale.

Fabric implements this model natively as part of the platform, rather than integrating an external authorization system. This allows Fabric to provide a consistent, explainable, and auditable entitlement model across datasets, streams, and services, while remaining fully self-contained and deployable in enterprise environments.

At a high level:
* Access is expressed as relationships between *subjects* and *resources*
* Relationships are evaluated dynamically at request time
* Authorization decisions are consistent, auditable, and explainable

For readers interested in the underlying design, Google’s public paper provides a concise overview of the Zanzibar model and its motivations:
* [Zanzibar: Google’s Consistent, Global Authorization System|https://research.google/pubs/pub48190/]

h2. Who can be entitled
Fabric supports entitlements for multiple actor and subject types:

* Users — individual human identities
* Groups — logical collections of users
* Applications — service and system identities

Access can be granted directly or inherited indirectly (for example, users gaining access via group membership).

h2. What can be governed
Fabric applies entitlements uniformly across platform resources, including:

* Datasets
** Table-level access
** Row-level access
** Column-level access
* Streams
** Publish and subscribe permissions
* Services
** Invocation and lifecycle control
* Queries and APIs
** Consistent enforcement regardless of access path

This unified approach allows organizations to define access once and apply it everywhere.

h2. On-Behalf-Of (OBO) and identity propagation
Fabric supports acting *On Behalf Of* (OBO) an end user across all access paths.

OBO allows a service or application to call Fabric while explicitly declaring:
* The *actor* making the request (the application)
* The *subject* on whose behalf the request is being made (the end user)

Fabric validates delegated identity using supported enterprise mechanisms, including:
* Validated SSO-based user identity
* Kerberos credential forwarding (double-hop) where available

This ensures that:
* End-user identity is propagated end-to-end
* Entitlements are evaluated against the correct user context
* Delegated access is auditable and explainable

Due to firm constraints, *SSO-to-Kerberos impersonation via S4U2 is not supported*. Fabric does not rely on S4U2 and instead validates and forwards already-authenticated credentials where applicable.

h2. Authentication integration
Fabric integrates directly with enterprise authentication mechanisms, including:

* Single Sign-On (SSO)
* Kerberos-based authentication and delegation

Authentication establishes identity, while entitlements determine *what that identity is allowed to do*. These concerns are deliberately separated to keep the model clear, auditable, and adaptable across environments.

h2. Audit, traceability, and compliance
Governance in Fabric is fully observable.

Fabric provides centralized, non-blocking audit capture for all governance-relevant activity, including:
* Metadata and configuration changes
* Dataset, stream, and service access decisions
* OBO usage and delegated access
* Runtime status and lifecycle events

Audit events are:
* Captured centrally by the platform
* Persisted in open, queryable formats (e.g. Parquet)
* Searchable and explorable through administrative tooling

This provides:
* End-to-end traceability of *who did what, when, and under which identity*
* Strong foundations for compliance, regulatory review, and incident investigation
* Confidence that governance decisions can be reconstructed and explained after the fact

h2. Simple entitlement examples

The following examples show how the same entitlement model governs *services*, *datasets*, and *combined service + data access with OBO*.

h3. Example: governed service lifecycle and invocation
{code:language=json}
{
  "payload": {
    "scopeType": "service",
    "scopeId": "service:oms/orders",
    "policies": [
      {
        "policyId": "oms.service.orders",
        "type": "SERVICE",
        "resourceId": "service:oms/orders",
        "bindings": [
          {
            "subject": "group:oms",
            "action": "service.start",
            "effect": "ALLOW"
          },
          {
            "subject": "group:desk1",
            "action": "service.invoke",
            "effect": "ALLOW"
          }
        ]
      }
    ]
  }
}
{code}

* OMS can start the *orders* service
* Desk1 can invoke the service
* The same policy applies regardless of gRPC, Arrow Flight, or other runtimes

h3. Example: governed dataset access with row-level filtering
{code:language=json}
{
  "payload": {
    "scopeType": "dataset",
    "scopeId": "dataset:oms/orders_hist",
    "policies": [
      {
        "policyId": "oms.dataset.orders_hist",
        "type": "DATASET",
        "resourceId": "dataset:oms/orders_hist",
        "bindings": [
          {
            "subject": "group:oms",
            "action": "data.write",
            "effect": "ALLOW"
          },
          {
            "subject": "group:desk1",
            "action": "data.read",
            "effect": "ALLOW",
            "obligations": {
              "rowFilters": [
                "desk = 'DESK1'"
              ]
            }
          }
        ]
      }
    ]
  }
}
{code}

* OMS owns and writes the dataset
* Desk1 can read the dataset
* Desk1 automatically receives only rows matching its entitlement filter

h3. Example: combined service + dataset policy with OBO context
This example illustrates how a service invocation and dataset access are evaluated *together* under OBO.

{code:language=json}
{
  "payload": {
    "policies": [
      {
        "policyId": "oms.service.orders",
        "type": "SERVICE",
        "resourceId": "service:oms/orders",
        "bindings": [
          {
            "subject": "group:desk1",
            "action": "service.invoke",
            "effect": "ALLOW"
          }
        ]
      },
      {
        "policyId": "oms.dataset.orders_hist",
        "type": "DATASET",
        "resourceId": "dataset:oms/orders_hist",
        "bindings": [
          {
            "subject": "group:desk1",
            "action": "data.read",
            "effect": "ALLOW",
            "obligations": {
              "rowFilters": [
                "desk = 'DESK1'"
              ]
            }
          }
        ]
      }
    ]
  }
}
{code}

In this flow:
* Desk1 invokes the *orders* service
* The service calls Fabric *on behalf of* the Desk1 user
* Fabric evaluates both service and dataset policies using the same OBO subject
* Row-level filtering is enforced automatically during query execution
* Audit records capture actor, subject, service, dataset, and decision context

h2. Pluggable sources of truth
Fabric is designed to support multiple entitlement sources of truth.

Entitlements can be derived from platform-managed configuration as well as integrated enterprise identity and authorization systems.

Regardless of where entitlements originate, Fabric remains the enforcement point, ensuring consistent behavior across all access paths.

h2. Security & Governance Summary

Fabric’s security and governance model forms a single, end-to-end control loop:

*Identity → OBO → Entitlements → Audit → Explainability*

*Identity*  
Every request entering Fabric is associated with a clear, authenticated identity.

*On-Behalf-Of (OBO)*  
Delegated access explicitly captures both actor and subject.

*Entitlements*  
Policies are evaluated once and applied uniformly everywhere.

*Audit*  
All governance-relevant actions are captured centrally.

*Explainability*  
Every allow or deny decision can be reconstructed and explained.

Together, these components ensure that Fabric delivers strong security and governance without sacrificing developer productivity, performance, or architectural flexibility.
