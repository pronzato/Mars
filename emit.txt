// MyRunnerConfigEmitter.java
// Generates a concrete class "MyRunnerConfig.java" that extends AbstractNamespacedConfig.
// Java 21+, no external deps.

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

public final class MyRunnerConfigEmitter {

  /* ===== Spec types (mirrors AbstractNamespacedConfig.Type) ===== */
  public enum Type {
    STRING, INT, LONG, DOUBLE, BOOLEAN,
    STRING_LIST, INT_LIST, LONG_LIST, DOUBLE_LIST, BOOLEAN_LIST
  }

  public static final class ParamSpec {
    public final String name;           // e.g., "batchSize"
    public final Type type;
    public final String defaultValue;   // code literal or CSV for lists; null = no default
    public final boolean mandatory;     // if true and no default, validated (subset: only when used)
    public final List<String> aliases;  // additional CLI keys; kebab will be auto-added based on name

    public ParamSpec(String name, Type type, String defaultValue, boolean mandatory, List<String> aliases) {
      this.name = name; this.type = type; this.defaultValue = defaultValue;
      this.mandatory = mandatory; this.aliases = aliases == null ? List.of() : List.copyOf(aliases);
    }
    public ParamSpec(String name, Type type, String defaultValue, boolean mandatory, String... aliases) {
      this(name, type, defaultValue, mandatory, Arrays.asList(aliases));
    }
  }

  public static final class SubsetSpec {
    public final String prefix;     // CLI key prefix (e.g., "amps")
    public final String className;  // public inner class & getter base name (e.g., "SourceAmps")
    public final List<ParamSpec> params;

    public SubsetSpec(String prefix, String className, List<ParamSpec> params) {
      this.prefix = prefix; this.className = className; this.params = List.copyOf(params);
    }
  }

  /* ===== Generator ===== */
  public static String generate(
      String packageName,                  // e.g., "com.example"
      String className,                    // e.g., "MyRunnerConfig"
      List<ParamSpec> topParams,
      List<SubsetSpec> subsets
  ) {
    String pkg = (packageName == null || packageName.isBlank()) ? "" : "package " + packageName + ";\n\n";
    StringBuilder sb = new StringBuilder(85_000);

    sb.append(pkg);
    sb.append("// Auto-generated by MyRunnerConfigEmitter\n");
    sb.append("import java.util.*;\n\n");
    sb.append("public final class ").append(className)
      .append(" extends AbstractNamespacedConfig<").append(className).append(".Builder, ").append(className).append(".Config> {\n\n");

    /* -------- Defaults -------- */
    sb.append("  /* ===== Defaults ===== */\n");
    sb.append("  static final class Defaults {\n");
    // top-level defaults
    for (ParamSpec p : topParams) {
      sb.append("    static final ").append(javaType(p.type)).append(" ").append(p.name)
        .append(" = ").append(defaultLiteral(p)).append(";\n");
    }
    // subset defaults
    for (SubsetSpec s : subsets) {
      for (ParamSpec p : s.params) {
        sb.append("    static final ").append(javaType(p.type)).append(" ")
          .append(s.prefix).append("_").append(p.name)
          .append(" = ").append(defaultLiteral(p)).append(";\n");
      }
    }
    sb.append("  }\n\n");

    /* -------- Subset public classes + builders -------- */
    for (SubsetSpec s : subsets) {
      // public immutable subset
      sb.append("  public static final class ").append(s.className).append(" {\n");
      for (ParamSpec p : s.params) {
        sb.append("    private final ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
      }
      sb.append("    private ").append(s.className).append("(");
      for (int i = 0; i < s.params.size(); i++) {
        if (i > 0) sb.append(", ");
        ParamSpec p = s.params.get(i);
        sb.append(javaType(p.type)).append(" ").append(p.name);
      }
      sb.append(") {\n");
      for (ParamSpec p : s.params) {
        sb.append("      this.").append(p.name).append(" = ").append(p.name).append(";\n");
      }
      sb.append("    }\n");
      for (ParamSpec p : s.params) {
        sb.append("    public ").append(javaType(p.type)).append(" get").append(capitalize(p.name)).append("() { return ").append(p.name).append("; }\n");
      }
      sb.append("    @Override public String toString() {\n");
      sb.append("      StringBuilder sb = new StringBuilder();\n");
      sb.append("      sb.append(\"").append(s.className).append("{\\n\");\n");
      for (ParamSpec p : s.params) {
        sb.append("      sb.append(\"  ").append(p.name).append("=\").append(String.valueOf(").append(p.name)
          .append(")).append(\"  (default=\").append(String.valueOf(Defaults.").append(s.prefix).append("_").append(p.name)
          .append(")).append(\")\\n\");\n");
      }
      sb.append("      sb.append(\"}\"); return sb.toString(); }\n");
      sb.append("  }\n\n");

      // subset builder (validate only if used)
      sb.append("  static final class ").append(s.className).append("Builder {\n");
      sb.append("    boolean used = false;\n");
      for (ParamSpec p : s.params) {
        if (p.defaultValue == null) {
          if (isList(p.type)) {
            sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(" = java.util.List.of();\n");
          } else if (p.type == Type.STRING) {
            sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
          } else {
            sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(" = ").append(javaDefault(p.type)).append(";\n");
          }
        } else {
          sb.append("    ").append(javaType(p.type)).append(" ").append(p.name)
            .append(" = Defaults.").append(s.prefix).append("_").append(p.name).append(";\n");
        }
      }
      for (ParamSpec p : s.params) {
        sb.append("    ").append(s.className).append("Builder with").append(capitalize(p.name)).append("(")
          .append(javaType(p.type)).append(" v) { this.").append(p.name).append(" = v; used = true; return this; }\n");
      }
      sb.append("    void validate() {\n");
      sb.append("      if (!used) return;\n");
      for (ParamSpec p : s.params) {
        if (p.mandatory && p.defaultValue == null) {
          sb.append("      if (");
          if (p.type == Type.STRING) {
            sb.append(p.name).append(" == null || ").append(p.name).append(".isBlank()");
          } else if (isList(p.type)) {
            sb.append(p.name).append(" == null || ").append(p.name).append(".isEmpty()");
          } else {
            sb.append("false");
          }
          sb.append(") throw new IllegalArgumentException(\"Missing mandatory parameter: ").append(s.prefix).append(".").append(p.name).append("\");\n");
        }
      }
      sb.append("    }\n");
      sb.append("    ").append(s.className).append(" build() { validate(); return new ").append(s.className).append("(");
      for (int i = 0; i < s.params.size(); i++) {
        if (i > 0) sb.append(", ");
        sb.append(s.params.get(i).name);
      }
      sb.append("); }\n");
      sb.append("  }\n\n");
    }

    /* -------- Top-level immutable Config -------- */
    sb.append("  public static final class Config {\n");
    for (ParamSpec p : topParams) {
      sb.append("    private final ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
    }
    for (SubsetSpec s : subsets) {
      sb.append("    private final ").append(s.className).append(" ").append(s.prefix).append(";\n");
    }
    sb.append("    private Config(");
    {
      boolean first = true;
      for (ParamSpec p : topParams) {
        if (!first) sb.append(", "); first = false;
        sb.append(javaType(p.type)).append(" ").append(p.name);
      }
      for (SubsetSpec s : subsets) {
        if (!first) sb.append(", "); first = false;
        sb.append(s.className).append(" ").append(s.prefix);
      }
    }
    sb.append(") {\n");
    for (ParamSpec p : topParams) {
      if (isList(p.type)) {
        sb.append("      this.").append(p.name).append(" = java.util.List.copyOf(").append(p.name).append(");\n");
      } else {
        sb.append("      this.").append(p.name).append(" = ").append(p.name).append(";\n");
      }
    }
    for (SubsetSpec s : subsets) {
      sb.append("      this.").append(s.prefix).append(" = ").append(s.prefix).append(";\n");
    }
    sb.append("    }\n");
    for (ParamSpec p : topParams) {
      sb.append("    public ").append(javaType(p.type)).append(" get").append(capitalize(p.name)).append("() { return ").append(p.name).append("; }\n");
    }
    for (SubsetSpec s : subsets) {
      sb.append("    public ").append(s.className).append(" get").append(s.className).append("() { return ").append(s.prefix).append("; }\n");
    }
    sb.append("    @Override public String toString() {\n");
    sb.append("      StringBuilder sb = new StringBuilder();\n");
    sb.append("      sb.append(\"").append(className).append(".Config{\\n\");\n");
    for (ParamSpec p : topParams) {
      sb.append("      sb.append(\"  ").append(p.name).append("=\").append(String.valueOf(").append(p.name)
        .append(")).append(\"  (default=\").append(String.valueOf(Defaults.").append(p.name).append(")).append(\")\\n\");\n");
    }
    for (SubsetSpec s : subsets) {
      sb.append("      sb.append(\"  ").append(s.className).append("=\\n\").append(").append(s.prefix).append(").append(\"\\n\");\n");
    }
    sb.append("      sb.append(\"}\"); return sb.toString(); }\n");
    sb.append("  }\n\n");

    /* -------- Builder -------- */
    sb.append("  public static final class Builder {\n");
    for (ParamSpec p : topParams) {
      if (p.defaultValue == null) {
        if (isList(p.type)) {
          sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(" = java.util.List.of();\n");
        } else if (p.type == Type.STRING) {
          sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
        } else {
          sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(" = ").append(javaDefault(p.type)).append(";\n");
        }
      } else {
        sb.append("    ").append(javaType(p.type)).append(" ").append(p.name)
          .append(" = Defaults.").append(p.name).append(";\n");
      }
    }
    for (SubsetSpec s : subsets) {
      sb.append("    final ").append(s.className).append("Builder ").append(s.prefix).append("Builder = new ").append(s.className).append("Builder();\n");
    }
    // withXxx setters
    for (ParamSpec p : topParams) {
      sb.append("    public Builder with").append(capitalize(p.name)).append("(").append(javaType(p.type)).append(" v) { this.")
        .append(p.name).append(" = ");
      if (isList(p.type)) sb.append("java.util.List.copyOf(v)"); else sb.append("v");
      sb.append("; return this; }\n");
    }
    // subset accessors
    for (SubsetSpec s : subsets) {
      sb.append("    public ").append(s.className).append("Builder ").append(s.prefix).append("() { return ").append(s.prefix).append("Builder; }\n");
    }
    // validate()
    sb.append("    Builder validate() {\n");
    for (ParamSpec p : topParams) {
      if (p.mandatory && p.defaultValue == null) {
        sb.append("      if (");
        if (p.type == Type.STRING) {
          sb.append(p.name).append(" == null || ").append(p.name).append(".isBlank()");
        } else if (isList(p.type)) {
          sb.append(p.name).append(" == null || ").append(p.name).append(".isEmpty()");
        } else {
          sb.append("false");
        }
        sb.append(") throw new IllegalArgumentException(\"Missing mandatory parameter: ").append(p.name).append("\");\n");
      }
    }
    for (SubsetSpec s : subsets) {
      sb.append("      ").append(s.prefix).append("Builder.validate();\n");
    }
    sb.append("      return this; }\n");
    // build()
    sb.append("    public Config build() {\n");
    sb.append("      validate();\n");
    for (SubsetSpec s : subsets) {
      sb.append("      ").append(s.className).append(" _").append(s.prefix).append(" = ").append(s.prefix).append("Builder.build();\n");
    }
    sb.append("      return new Config(");
    {
      boolean first = true;
      for (ParamSpec p : topParams) {
        if (!first) sb.append(", "); first = false;
        sb.append(p.name);
      }
      for (SubsetSpec s : subsets) {
        if (!first) sb.append(", "); first = false;
        sb.append("_").append(s.prefix);
      }
    }
    sb.append(");\n");
    sb.append("    }\n");
    sb.append("  }\n\n");

    sb.append("  public static Builder builder() { return new Builder(); }\n\n");

    /* -------- Abstract base overrides -------- */
    sb.append("  @Override protected Builder newBuilder() { return builder(); }\n");
    sb.append("  @Override protected Config build(Builder builder) { return builder.build(); }\n\n");

    // topAliases()
    sb.append("  @Override protected Map<String, List<String>> topAliases() {\n");
    sb.append("    Map<String, List<String>> m = new LinkedHashMap<>();\n");
    for (ParamSpec p : topParams) {
      List<String> all = withKebab(p.name, p.aliases);
      sb.append("    m.put(\"").append(p.name).append("\", List.of(").append(joinQuoted(all)).append("));\n");
    }
    sb.append("    return m; }\n\n");

    // subsetAliases()
    sb.append("  @Override protected Map<String, Map<String, List<String>>> subsetAliases() {\n");
    sb.append("    Map<String, Map<String, List<String>>> out = new LinkedHashMap<>();\n");
    for (SubsetSpec s : subsets) {
      sb.append("    { Map<String, List<String>> m = new LinkedHashMap<>();\n");
      for (ParamSpec p : s.params) {
        List<String> all = withKebab(p.name, p.aliases);
        sb.append("      m.put(\"").append(p.name).append("\", List.of(").append(joinQuoted(all)).append("));\n");
      }
      sb.append("      out.put(\"").append(s.prefix).append("\", m); }\n");
    }
    sb.append("    return out; }\n\n");

    // applyTopKV
    sb.append("  @Override protected void applyTopKV(Builder b, String canonicalKey, String rawValue) {\n");
    sb.append("    switch (canonicalKey) {\n");
    for (ParamSpec p : topParams) {
      sb.append("      case \"").append(p.name).append("\" -> ");
      sb.append("b.with").append(capitalize(p.name)).append("(").append(parseExpr("rawValue", p.type)).append(");\n");
    }
    sb.append("      default -> { /* ignore */ }\n");
    sb.append("    }\n");
    sb.append("  }\n\n");

    // applySubsetKV
    sb.append("  @Override protected void applySubsetKV(Builder b, String prefix, String canonicalField, String rawValue) {\n");
    sb.append("    switch (prefix) {\n");
    for (SubsetSpec s : subsets) {
      sb.append("      case \"").append(s.prefix).append("\" -> {\n");
      sb.append("        switch (canonicalField) {\n");
      for (ParamSpec p : s.params) {
        sb.append("          case \"").append(p.name).append("\" -> b.").append(s.prefix)
          .append("Builder.with").append(capitalize(p.name)).append("(")
          .append(parseExpr("rawValue", p.type)).append(");\n");
      }
      sb.append("          default -> { /* ignore */ }\n");
      sb.append("        }\n");
      sb.append("      }\n");
    }
    sb.append("      default -> { /* ignore */ }\n");
    sb.append("    }\n");
    sb.append("  }\n\n");

    // topParamsInfo (for help)
    sb.append("  @Override protected java.util.List<AbstractNamespacedConfig.ParamInfo> topParamsInfo() {\n");
    sb.append("    return java.util.List.of(\n");
    for (int i = 0; i < topParams.size(); i++) {
      ParamSpec p = topParams.get(i);
      sb.append("      new AbstractNamespacedConfig.ParamInfo(")
        .append("\"").append(esc(p.name)).append("\", ")
        .append("AbstractNamespacedConfig.Type.").append(mapBaseType(p.type)).append(", ")
        .append(p.mandatory ? "true" : "false").append(", ")
        .append("Defaults.").append(p.name).append(", ")
        .append("java.util.List.of(").append(joinQuoted(withKebab(p.name, p.aliases))).append("))");
      if (i < topParams.size() - 1) sb.append(",\n"); else sb.append("\n");
    }
    sb.append("    );\n");
    sb.append("  }\n\n");

    // subsetsInfo (for help)
    sb.append("  @Override protected java.util.List<AbstractNamespacedConfig.SubsetInfo> subsetsInfo() {\n");
    sb.append("    return java.util.List.of(\n");
    for (int si = 0; si < subsets.size(); si++) {
      SubsetSpec s = subsets.get(si);
      sb.append("      new AbstractNamespacedConfig.SubsetInfo(\"").append(esc(s.prefix)).append("\", ")
        .append("\"").append(esc(s.className)).append("\", ")
        .append("java.util.List.of(\n");
      for (int i = 0; i < s.params.size(); i++) {
        ParamSpec p = s.params.get(i);
        sb.append("        new AbstractNamespacedConfig.ParamInfo(")
          .append("\"").append(esc(p.name)).append("\", ")
          .append("AbstractNamespacedConfig.Type.").append(mapBaseType(p.type)).append(", ")
          .append(p.mandatory ? "true" : "false").append(", ")
          .append("Defaults.").append(s.prefix).append("_").append(p.name).append(", ")
          .append("java.util.List.of(").append(joinQuoted(withKebab(p.name, p.aliases))).append("))");
        if (i < s.params.size() - 1) sb.append(",\n"); else sb.append("\n");
      }
      sb.append("      ))");
      if (si < subsets.size() - 1) sb.append(",\n"); else sb.append("\n");
    }
    sb.append("    );\n");
    sb.append("  }\n\n");

    // === CLI convenience (avoid hiding instance methods in the abstract base) ===
    sb.append("  public static final class CLI {\n");
    sb.append("    /** Parse args into Config (supports --k=v, --k v, flags, subsets). */\n");
    sb.append("    public static ").append(className).append(".Config fromArgs(String[] args) {\n");
    sb.append("      return new ").append(className).append("().fromArgs(args);\n");
    sb.append("    }\n");
    sb.append("    /** Print help text. */\n");
    sb.append("    public static void printHelp() { new ").append(className).append("().printHelp(); }\n");
    sb.append("  }\n\n");

    sb.append("}\n"); // end class

    return sb.toString();
  }

  /* ===== Helper functions for codegen ===== */

  private static String javaType(Type t) {
    return switch (t) {
      case STRING -> "String";
      case INT -> "int";
      case LONG -> "long";
      case DOUBLE -> "double";
      case BOOLEAN -> "boolean";
      case STRING_LIST -> "java.util.List<String>";
      case INT_LIST -> "java.util.List<Integer>";
      case LONG_LIST -> "java.util.List<Long>";
      case DOUBLE_LIST -> "java.util.List<Double>";
      case BOOLEAN_LIST -> "java.util.List<Boolean>";
    };
  }

  private static boolean isList(Type t) {
    return switch (t) {
      case STRING_LIST, INT_LIST, LONG_LIST, DOUBLE_LIST, BOOLEAN_LIST -> true;
      default -> false;
    };
  }

  private static String javaDefault(Type t) {
    return switch (t) {
      case STRING -> "null";
      case INT -> "0";
      case LONG -> "0L";
      case DOUBLE -> "0.0d";
      case BOOLEAN -> "false";
      case STRING_LIST, INT_LIST, LONG_LIST, DOUBLE_LIST, BOOLEAN_LIST -> "java.util.List.of()";
    };
  }

  private static String defaultLiteral(ParamSpec p) {
    if (p.defaultValue == null) return javaDefault(p.type);
    String dv = p.defaultValue;
    return switch (p.type) {
      case STRING -> "\"" + esc(dv) + "\"";
      case INT    -> dv;
      case LONG   -> dv.endsWith("L") ? dv : dv + "L";
      case DOUBLE -> dv.contains(".") ? dv : dv + ".0";
      case BOOLEAN-> dv.toLowerCase(Locale.ROOT);

      case STRING_LIST  -> "java.util.List.of(" + listJoin(dv, Type.STRING_LIST)  + ")";
      case INT_LIST     -> "java.util.List.of(" + listJoin(dv, Type.INT_LIST)     + ")";
      case LONG_LIST    -> "java.util.List.of(" + listJoin(dv, Type.LONG_LIST)    + ")";
      case DOUBLE_LIST  -> "java.util.List.of(" + listJoin(dv, Type.DOUBLE_LIST)  + ")";
      case BOOLEAN_LIST -> "java.util.List.of(" + listJoin(dv, Type.BOOLEAN_LIST) + ")";
    };
  }

  private static String listJoin(String csv, Type t) {
    String[] parts = Arrays.stream(csv.split(","))
        .map(String::trim).filter(s -> !s.isEmpty()).toArray(String[]::new);
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < parts.length; i++) {
      if (i > 0) sb.append(", ");
      String v = parts[i];
      switch (t) {
        case STRING_LIST  -> sb.append("\"").append(esc(v)).append("\"");
        case INT_LIST     -> sb.append(Integer.parseInt(v));
        case LONG_LIST    -> sb.append(v.endsWith("L") ? v : v + "L");
        case DOUBLE_LIST  -> sb.append(v.contains(".") ? v : v + ".0");
        case BOOLEAN_LIST -> sb.append(v.toLowerCase(Locale.ROOT));
        default -> throw new IllegalArgumentException("not a list type");
      }
    }
    return sb.toString();
  }

  private static String parseExpr(String var, Type t) {
    return switch (t) {
      case STRING -> var;
      case INT -> "Integer.parseInt(" + var + ")";
      case LONG -> "Long.parseLong(" + var + ")";
      case DOUBLE -> "Double.parseDouble(" + var + ")";
      case BOOLEAN -> "Boolean.parseBoolean(" + var + ")";
      case STRING_LIST -> "parseStringList(" + var + ")";
      case INT_LIST -> "parseIntList(" + var + ")";
      case LONG_LIST -> "parseLongList(" + var + ")";
      case DOUBLE_LIST -> "parseDoubleList(" + var + ")";
      case BOOLEAN_LIST -> "parseBooleanList(" + var + ")";
    };
  }

  private static String capitalize(String s) {
    if (s == null || s.isEmpty()) return s;
    return Character.toUpperCase(s.charAt(0)) + s.substring(1);
  }

  private static String esc(String s) { return s.replace("\\", "\\\\").replace("\"", "\\\""); }

  private static String toKebab(String camel) {
    StringBuilder sb = new StringBuilder(camel.length() + 8);
    for (char c : camel.toCharArray()) {
      if (Character.isUpperCase(c)) sb.append('-').append(Character.toLowerCase(c));
      else sb.append(c);
    }
    return sb.toString();
  }

  private static String joinQuoted(List<String> items) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < items.size(); i++) {
      if (i > 0) sb.append(", ");
      sb.append("\"").append(esc(items.get(i))).append("\"");
    }
    return sb.toString();
  }

  private static String mapBaseType(Type t) {
    // Map our emitter Type -> AbstractNamespacedConfig.Type name
    return switch (t) {
      case STRING -> "STRING";
      case INT -> "INT";
      case LONG -> "LONG";
      case DOUBLE -> "DOUBLE";
      case BOOLEAN -> "BOOLEAN";
      case STRING_LIST -> "STRING_LIST";
      case INT_LIST -> "INT_LIST";
      case LONG_LIST -> "LONG_LIST";
      case DOUBLE_LIST -> "DOUBLE_LIST";
      case BOOLEAN_LIST -> "BOOLEAN_LIST";
    };
  }

  private static List<String> withKebab(String name, List<String> aliases) {
    List<String> all = new ArrayList<>();
    all.add(name);
    String kebab = toKebab(name);
    if (!all.contains(kebab)) all.add(kebab);
    if (aliases != null) all.addAll(aliases);
    return all;
  }

  /* ===== Tiny demo: writes MyRunnerConfig.java next to this file ===== */
  public static void main(String[] args) throws IOException {
    // Top-level params
    var top = List.of(
        new ParamSpec("chronicleDir", Type.STRING, "./chronicle", false, "chronicle-dir", "cdir"),
        new ParamSpec("mode",         Type.STRING, "stream",      false, "m"),
        new ParamSpec("verbose",      Type.BOOLEAN, "false",      false, "v"),
        new ParamSpec("batchSize",    Type.INT,     "1000",       false, "batch-size","bs"),
        new ParamSpec("topics",       Type.STRING_LIST, "orders,payments", false),
        new ParamSpec("partitions",   Type.INT_LIST,    "0,1",           false)
    );

    // Subset: CLI prefix "amps", public class name "SourceAmps"
    var amps = new SubsetSpec(
        "amps", "SourceAmps",
        List.of(
            new ParamSpec("p1", Type.STRING,  null,  true,  "p-1"),
            new ParamSpec("p2", Type.INT,     "2",   false, "p-2"),
            new ParamSpec("p3", Type.BOOLEAN, "true",false, "p-3")
        )
    );

    String src = generate("com.example", "MyRunnerConfig", top, List.of(amps));
    Path out = Path.of("MyRunnerConfig.java");
    Files.writeString(out, src, StandardCharsets.UTF_8);
    System.out.println("Wrote " + out.toAbsolutePath());
  }
}
