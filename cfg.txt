// NamespacedFlatConfigGenerator.java
// Generates one Java class with:
// - Defaults → Builder (withXxx) → Config (getters)
// - Namespaced subsets as static inner classes (e.g., amps.p1 → Amps.getP1())
// - fromArgs(): --k=v and --k v, --flag/--no-flag, kebab↔camel aliases
// - printHelp(): shows keys, aliases, defaults, mandatory
// Java 21+, no external deps.

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

public final class NamespacedFlatConfigGenerator {

    /* ===== Specs ===== */
    public enum Type { STRING, INT, LONG, DOUBLE, BOOLEAN }
    public enum Visibility { PUBLIC, PACKAGE_PRIVATE }

    /** A single parameter definition (usable for top-level or subset). */
    public static final class ParamSpec {
        public final String name;         // canonical simple name (no dots), e.g. "batchSize"
        public final Type type;
        public final String defaultValue; // code literal string for default; null => no default
        public final boolean mandatory;   // if true and no default → must be set
        public final List<String> aliases;// alternative key spellings (kebab accepted)

        public ParamSpec(String name, Type type, String defaultValue, boolean mandatory, List<String> aliases) {
            this.name = Objects.requireNonNull(name);
            this.type = Objects.requireNonNull(type);
            this.defaultValue = defaultValue;
            this.mandatory = mandatory;
            this.aliases = aliases == null ? List.of() : List.copyOf(aliases);
        }
        public ParamSpec(String name, Type type, String defaultValue, boolean mandatory, String... aliases) {
            this(name, type, defaultValue, mandatory, Arrays.asList(aliases));
        }
    }

    /** A namespaced subset (e.g., prefix "amps" → static inner class "Amps"). */
    public static final class SubsetSpec {
        public final String prefix;              // e.g., "amps" (used in CLI keys: amps.p1)
        public final String className;           // e.g., "Amps"
        public final List<ParamSpec> params;

        public SubsetSpec(String prefix, String className, List<ParamSpec> params) {
            this.prefix = Objects.requireNonNull(prefix);
            this.className = Objects.requireNonNull(className);
            this.params = List.copyOf(params);
        }
    }

    /* ===== Generator ===== */
    public static String generate(
            String packageNameOrNull,
            String className,
            Visibility visibility,
            List<ParamSpec> topParams,
            List<SubsetSpec> subsets
    ) {
        String pkg = (packageNameOrNull == null || packageNameOrNull.isBlank())
                ? "" : "package " + packageNameOrNull + ";\n\n";
        String classVis = (visibility == Visibility.PUBLIC) ? "public " : "";

        StringBuilder sb = new StringBuilder(40_000);
        sb.append(pkg);
        sb.append("// Auto-generated by NamespacedFlatConfigGenerator\n");
        sb.append("import java.util.*;\n\n");

        sb.append(classVis).append("final class ").append(className).append(" {\n\n");

        /* ===== Defaults ===== */
        sb.append("  // ===== Defaults =====\n");
        sb.append("  static final class Defaults {\n");
        for (ParamSpec p : topParams) {
            sb.append("    static final ").append(javaType(p.type)).append(" ").append(p.name)
              .append(" = ").append(defaultLiteral(p)).append(";\n");
        }
        for (SubsetSpec s : subsets) {
            for (ParamSpec p : s.params) {
                sb.append("    static final ").append(javaType(p.type)).append(" ")
                  .append(s.prefix).append("_").append(p.name)
                  .append(" = ").append(defaultLiteral(p)).append(";\n");
            }
        }
        sb.append("  }\n\n");

        /* ===== Subset inner classes ===== */
        for (SubsetSpec s : subsets) {
            sb.append("  // ===== Subset: ").append(s.prefix).append(" → ").append(s.className).append(" =====\n");
            // Immutable view
            sb.append("  static final class ").append(s.className).append(" {\n");
            for (ParamSpec p : s.params) {
                sb.append("    private final ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
            }
            sb.append("    private ").append(s.className).append("(");
            for (int i = 0; i < s.params.size(); i++) {
                if (i > 0) sb.append(", ");
                ParamSpec p = s.params.get(i);
                sb.append(javaType(p.type)).append(" ").append(p.name);
            }
            sb.append(") {\n");
            for (ParamSpec p : s.params) {
                sb.append("      this.").append(p.name).append(" = ").append(p.name).append(";\n");
            }
            sb.append("    }\n");
            for (ParamSpec p : s.params) {
                sb.append("    ").append(publicOrEmpty(visibility)).append(" ").append(javaType(p.type))
                  .append(" get").append(capitalize(p.name)).append("() { return ").append(p.name).append("; }\n");
            }
            sb.append("    @Override public String toString() {\n");
            sb.append("      StringBuilder sb = new StringBuilder(\"").append(s.className).append("{\\n}\");\n");
            sb.append("      sb.setLength(0);\n");
            sb.append("      sb.append(\"").append(s.className).append("{\\n\");\n");
            for (ParamSpec p : s.params) {
                sb.append("      sb.append(\"  ").append(p.name).append("=\").append(").append(p.name)
                  .append(").append(\"  (default=\").append(Defaults.").append(s.prefix).append("_").append(p.name)
                  .append(").append(\")\\n\");\n");
            }
            sb.append("      sb.append(\"}\"); return sb.toString(); }\n");
            sb.append("  }\n\n");

            // Mutable builder for subset (fluent withXxx)
            sb.append("  static final class ").append(s.className).append("Builder {\n");
            for (ParamSpec p : s.params) {
                if (p.defaultValue == null) {
                    if (p.type == Type.STRING) {
                        sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
                    } else {
                        sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(" = ").append(javaDefault(p.type)).append(";\n");
                    }
                } else {
                    sb.append("    ").append(javaType(p.type)).append(" ").append(p.name)
                      .append(" = Defaults.").append(s.prefix).append("_").append(p.name).append(";\n");
                }
            }
            for (ParamSpec p : s.params) {
                sb.append("    ").append(s.className).append("Builder with").append(capitalize(p.name)).append("(")
                  .append(javaType(p.type)).append(" v) { this.").append(p.name).append(" = v; return this; }\n");
            }
            sb.append("    void validate() {\n");
            for (ParamSpec p : s.params) {
                if (p.mandatory && p.defaultValue == null) {
                    sb.append("      if (");
                    if (p.type == Type.STRING) {
                        sb.append(p.name).append(" == null || ").append(p.name).append(".isBlank()");
                    } else {
                        sb.append("false");
                    }
                    sb.append(") throw new IllegalArgumentException(\"Missing mandatory parameter: ").append(s.prefix).append(".").append(p.name).append("\");\n");
                }
            }
            sb.append("    }\n");
            sb.append("    ").append(s.className).append(" build() { validate(); return new ").append(s.className).append("(");
            for (int i = 0; i < s.params.size(); i++) {
                if (i > 0) sb.append(", ");
                sb.append(s.params.get(i).name);
            }
            sb.append("); }\n");
            sb.append("  }\n\n");
        }

        /* ===== Top-level Config ===== */
        sb.append("  // ===== Config (immutable) =====\n");
        sb.append("  static final class Config {\n");
        for (ParamSpec p : topParams) {
            sb.append("    private final ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
        }
        for (SubsetSpec s : subsets) {
            sb.append("    private final ").append(s.className).append(" ").append(s.prefix).append(";\n");
        }
        sb.append("    private Config(");
        boolean first = true;
        for (ParamSpec p : topParams) {
            if (!first) sb.append(", "); first = false;
            sb.append(javaType(p.type)).append(" ").append(p.name);
        }
        for (SubsetSpec s : subsets) {
            if (!first) sb.append(", "); first = false;
            sb.append(s.className).append(" ").append(s.prefix);
        }
        sb.append(") {\n");
        for (ParamSpec p : topParams) {
            sb.append("      this.").append(p.name).append(" = ").append(p.name).append(";\n");
        }
        for (SubsetSpec s : subsets) {
            sb.append("      this.").append(s.prefix).append(" = ").append(s.prefix).append(";\n");
        }
        sb.append("    }\n");
        for (ParamSpec p : topParams) {
            sb.append("    ").append(publicOrEmpty(visibility)).append(" ").append(javaType(p.type))
              .append(" get").append(capitalize(p.name)).append("() { return ").append(p.name).append("; }\n");
        }
        for (SubsetSpec s : subsets) {
            sb.append("    ").append(publicOrEmpty(visibility)).append(" ").append(s.className)
              .append(" get").append(capitalize(s.prefix)).append("() { return ").append(s.prefix).append("; }\n");
        }
        sb.append("    @Override public String toString() {\n");
        sb.append("      StringBuilder sb = new StringBuilder(\"").append(className).append(".Config{\\n}\");\n");
        sb.append("      sb.setLength(0); sb.append(\"").append(className).append(".Config{\\n\");\n");
        for (ParamSpec p : topParams) {
            sb.append("      sb.append(\"  ").append(p.name).append("=\").append(").append(p.name)
              .append(").append(\"  (default=\").append(Defaults.").append(p.name).append(").append(\")\\n\");\n");
        }
        for (SubsetSpec s : subsets) {
            sb.append("      sb.append(\"  ").append(s.prefix).append("=\\n\").append(").append(s.prefix).append(").append(\"\\n\");\n");
        }
        sb.append("      sb.append(\"}\"); return sb.toString(); }\n");
        sb.append("  }\n\n");

        /* ===== Builder ===== */
        sb.append("  // ===== Builder =====\n");
        sb.append("  static final class Builder {\n");
        for (ParamSpec p : topParams) {
            if (p.defaultValue == null) {
                if (p.type == Type.STRING) sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
                else sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(" = ").append(javaDefault(p.type)).append(";\n");
            } else {
                sb.append("    ").append(javaType(p.type)).append(" ").append(p.name)
                  .append(" = Defaults.").append(p.name).append(";\n");
            }
        }
        for (SubsetSpec s : subsets) {
            sb.append("    final ").append(s.className).append("Builder ").append(s.prefix).append("Builder = new ").append(s.className).append("Builder();\n");
        }
        // withXxx setters for top-level
        for (ParamSpec p : topParams) {
            sb.append("    Builder with").append(capitalize(p.name)).append("(").append(javaType(p.type)).append(" v) { this.")
              .append(p.name).append(" = v; return this; }\n");
        }
        // accessors for subset builders (no lambdas)
        for (SubsetSpec s : subsets) {
            sb.append("    ").append(s.className).append("Builder ").append(s.prefix).append("() { return ").append(s.prefix).append("Builder; }\n");
        }
        // getters on builder (introspection)
        for (ParamSpec p : topParams) {
            sb.append("    ").append(publicOrEmpty(visibility)).append(" ").append(javaType(p.type))
              .append(" get").append(capitalize(p.name)).append("() { return ").append(p.name).append("; }\n");
        }
        for (SubsetSpec s : subsets) {
            for (ParamSpec p : s.params) {
                sb.append("    ").append(publicOrEmpty(visibility)).append(" ").append(javaType(p.type))
                  .append(" get").append(capitalize(s.prefix)).append(capitalize(p.name))
                  .append("() { return ").append(s.prefix).append("Builder.").append(p.name).append("; }\n");
            }
        }
        // validate()
        sb.append("    Builder validate() {\n");
        for (ParamSpec p : topParams) {
            if (p.mandatory && p.defaultValue == null) {
                sb.append("      if (");
                if (p.type == Type.STRING) sb.append(p.name).append(" == null || ").append(p.name).append(".isBlank()");
                else sb.append("false");
                sb.append(") throw new IllegalArgumentException(\"Missing mandatory parameter: ").append(p.name).append("\");\n");
            }
        }
        for (SubsetSpec s : subsets) {
            sb.append("      ").append(s.prefix).append("Builder.validate();\n");
        }
        sb.append("      return this; }\n");
        // build()
        sb.append("    Config build() {\n");
        sb.append("      validate();\n");
        for (SubsetSpec s : subsets) {
            sb.append("      ").append(s.className).append(" _").append(s.prefix).append(" = ").append(s.prefix).append("Builder.build();\n");
        }
        sb.append("      return new Config(");
        first = true;
        for (ParamSpec p : topParams) { if (!first) sb.append(", "); first = false; sb.append(p.name); }
        for (SubsetSpec s : subsets) { if (!first) sb.append(", "); first = false; sb.append("_").append(s.prefix); }
        sb.append(");\n");
        sb.append("    }\n");
        sb.append("  }\n\n");

        sb.append("  static Builder builder() { return new Builder(); }\n\n");

        /* ===== Aliases for fromArgs & help ===== */
        sb.append("  private static Map<String,List<String>> topAliasMap() {\n");
        sb.append("    Map<String,List<String>> m = new LinkedHashMap<>();\n");
        for (ParamSpec p : topParams) {
            List<String> all = new ArrayList<>(); all.add(p.name); all.addAll(p.aliases);
            String kebab = toKebab(p.name); if (!all.contains(kebab)) all.add(kebab);
            sb.append("    m.put(\"").append(p.name).append("\", List.of(").append(joinQuoted(all)).append("));\n");
        }
        sb.append("    return m; }\n\n");

        sb.append("  private static Map<String,Map<String,List<String>>> subsetAliasMap() {\n");
        sb.append("    Map<String,Map<String,List<String>>> out = new LinkedHashMap<>();\n");
        for (SubsetSpec s : subsets) {
            sb.append("    { Map<String,List<String>> m = new LinkedHashMap<>();\n");
            for (ParamSpec p : s.params) {
                List<String> all = new ArrayList<>(); all.add(p.name); all.addAll(p.aliases);
                String kebab = toKebab(p.name); if (!all.contains(kebab)) all.add(kebab);
                sb.append("      m.put(\"").append(p.name).append("\", List.of(").append(joinQuoted(all)).append("));\n");
            }
            sb.append("      out.put(\"").append(s.prefix).append("\", m); }\n");
        }
        sb.append("    return out; }\n\n");

        /* ===== fromArgs(): --k=v and --k v, flags, kebab/camel ===== */
        sb.append("  static Config fromArgs(String[] args) {\n");
        sb.append("    Builder b = builder();\n");
        sb.append("    Map<String,List<String>> tmap = topAliasMap();\n");
        sb.append("    Map<String,Map<String,List<String>>> smap = subsetAliasMap();\n");
        sb.append("    for (int i=0; i<args.length; i++) {\n");
        sb.append("      String tok = args[i]; if (tok == null || !tok.startsWith(\"--\")) continue;\n");
        sb.append("      String s = tok.substring(2);\n");
        sb.append("      boolean neg = s.startsWith(\"no-\"); if (neg) s = s.substring(3);\n");
        sb.append("      String key; String val;\n");
        sb.append("      int eq = s.indexOf('=');\n");
        sb.append("      if (eq > 0) { key = s.substring(0,eq); val = s.substring(eq+1); }\n");
        sb.append("      else { key = s; if (i+1<args.length && !args[i+1].startsWith(\"--\")) val = args[++i]; else val = neg?\"false\":\"true\"; }\n");
        sb.append("      key = toCamelDotted(key);\n");
        sb.append("      int dot = key.indexOf('.');\n");
        sb.append("      if (dot < 0) {\n");
        sb.append("        // top-level\n");
        for (ParamSpec p : topParams) {
            sb.append("        if (matches(key, tmap.get(\"").append(p.name).append("\"))) {\n");
            switch (p.type) {
                case STRING -> sb.append("          b.with").append(capitalize(p.name)).append("(val);\n");
                case INT    -> sb.append("          b.with").append(capitalize(p.name)).append("(Integer.parseInt(val));\n");
                case LONG   -> sb.append("          b.with").append(capitalize(p.name)).append("(Long.parseLong(val));\n");
                case DOUBLE -> sb.append("          b.with").append(capitalize(p.name)).append("(Double.parseDouble(val));\n");
                case BOOLEAN-> sb.append("          b.with").append(capitalize(p.name)).append("(Boolean.parseBoolean(val));\n");
            }
            sb.append("          continue; }\n");
        }
        sb.append("        continue;\n");
        sb.append("      }\n");
        sb.append("      // subset: prefix.field\n");
        sb.append("      String pref = key.substring(0, dot);\n");
        sb.append("      String field = key.substring(dot+1);\n");
        for (SubsetSpec s : subsets) {
            sb.append("      if (pref.equals(\"").append(s.prefix).append("\")) {\n");
            sb.append("        Map<String,List<String>> fam = smap.get(\"").append(s.prefix).append("\");\n");
            for (ParamSpec p : s.params) {
                sb.append("        if (matches(field, fam.get(\"").append(p.name).append("\"))) {\n");
                switch (p.type) {
                    case STRING -> sb.append("          b.").append(s.prefix).append("Builder.with").append(capitalize(p.name)).append("(val);\n");
                    case INT    -> sb.append("          b.").append(s.prefix).append("Builder.with").append(capitalize(p.name)).append("(Integer.parseInt(val));\n");
                    case LONG   -> sb.append("          b.").append(s.prefix).append("Builder.with").append(capitalize(p.name)).append("(Long.parseLong(val));\n");
                    case DOUBLE -> sb.append("          b.").append(s.prefix).append("Builder.with").append(capitalize(p.name)).append("(Double.parseDouble(val));\n");
                    case BOOLEAN-> sb.append("          b.").append(s.prefix).append("Builder.with").append(capitalize(p.name)).append("(Boolean.parseBoolean(val));\n");
                }
                sb.append("          continue; }\n");
            }
            sb.append("      }\n");
        }
        sb.append("    }\n");
        sb.append("    return b.build();\n");
        sb.append("  }\n\n");

        /* ===== printHelp() ===== */
        sb.append("  static void printHelp() {\n");
        sb.append("    StringBuilder h = new StringBuilder();\n");
        sb.append("    h.append(\"Options (top-level):\\n\");\n");
        for (ParamSpec p : topParams) {
            sb.append("    h.append(\"  --").append(toKebab(p.name)).append("\");\n");
            if (!p.aliases.isEmpty()) {
                sb.append(" h.append(\"  aliases: ");
                for (int i=0;i<p.aliases.size();i++) { if (i>0) sb.append(", "); sb.append(p.aliases.get(i)); }
                sb.append("\");\n");
            }
            sb.append("    h.append(\"  type=").append(p.type.name().toLowerCase(Locale.ROOT)).append("\");\n");
            sb.append("    h.append(\"  default=\").append(String.valueOf(Defaults.").append(p.name).append("));\n");
            if (p.mandatory && p.defaultValue == null) sb.append("    h.append(\"  (mandatory)\");\n");
            sb.append("    h.append(\"\\n\");\n");
        }
        for (SubsetSpec s : subsets) {
            sb.append("    h.append(\"\\nSubset ").append(s.prefix).append(" (use as --").append(s.prefix).append(".<field>=... or space):\\n\");\n");
            for (ParamSpec p : s.params) {
                sb.append("    h.append(\"  --").append(s.prefix).append(".").append(toKebab(p.name)).append("\");\n");
                if (!p.aliases.isEmpty()) {
                    sb.append(" h.append(\"  aliases: ");
                    for (int i=0;i<p.aliases.size();i++) { if (i>0) sb.append(", "); sb.append(p.aliases.get(i)); }
                    sb.append("\");\n");
                }
                sb.append("    h.append(\"  type=").append(p.type.name().toLowerCase(Locale.ROOT)).append("\");\n");
                sb.append("    h.append(\"  default=\").append(String.valueOf(Defaults.").append(s.prefix).append("_").append(p.name).append("));\n");
                if (p.mandatory && p.defaultValue == null) sb.append("    h.append(\"  (mandatory)\");\n");
                sb.append("    h.append(\"\\n\");\n");
            }
        }
        sb.append("    System.out.print(h.toString());\n");
        sb.append("  }\n\n");

        /* ===== helpers embedded in generated class ===== */
        sb.append("  private static boolean matches(String key, List<String> aliases) {\n");
        sb.append("    if (aliases == null) return false; for (String a : aliases) if (a.equals(key)) return true; return false; }\n");
        sb.append("  private static String toCamel(String key) {\n");
        sb.append("    if (key.indexOf('-') < 0) return key; StringBuilder _sb = new StringBuilder(key.length()); boolean up=false; for (char c: key.toCharArray()) { if (c=='-'){up=true;continue;} _sb.append(up?Character.toUpperCase(c):c); up=false; } return _sb.toString(); }\n");
        sb.append("  private static String toCamelDotted(String dotted) {\n");
        sb.append("    String[] parts = dotted.split(\"\\\\.\"); for (int i=0;i<parts.length;i++) parts[i]=toCamel(parts[i]); return String.join(\".\", parts); }\n");

        sb.append("}\n"); // end generated class

        return sb.toString();
    }

    /* ===== Generator-side helpers ===== */
    private static String publicOrEmpty(Visibility v){ return v==Visibility.PUBLIC ? "public" : ""; }
    private static String capitalize(String s){ return (s==null||s.isEmpty())?s:Character.toUpperCase(s.charAt(0))+s.substring(1); }
    private static String toKebab(String camel){
        StringBuilder sb = new StringBuilder(camel.length()+8);
        for (char c: camel.toCharArray()) if (Character.isUpperCase(c)) sb.append('-').append(Character.toLowerCase(c)); else sb.append(c);
        return sb.toString();
    }
    private static String joinQuoted(List<String> items){
        StringBuilder sb = new StringBuilder();
        for (int i=0;i<items.size();i++){ if (i>0) sb.append(", "); sb.append("\"").append(escape(items.get(i))).append("\""); }
        return sb.toString();
    }
    private static String javaType(Type t){
        return switch (t){ case STRING->"String"; case INT->"int"; case LONG->"long"; case DOUBLE->"double"; case BOOLEAN->"boolean"; };
    }
    private static String javaDefault(Type t){
        return switch (t){ case STRING->"null"; case INT->"0"; case LONG->"0L"; case DOUBLE->"0.0d"; case BOOLEAN->"false"; };
    }
    private static String defaultLiteral(ParamSpec p){
        if (p.defaultValue==null) return javaDefault(p.type);
        String dv = p.defaultValue;
        return switch (p.type){
            case STRING -> "\"" + escape(dv) + "\"";
            case INT    -> dv;
            case LONG   -> dv.endsWith("L") ? dv : dv + "L";
            case DOUBLE -> dv.contains(".") ? dv : dv + ".0";
            case BOOLEAN-> dv.toLowerCase(Locale.ROOT);
        };
    }
    private static String escape(String s){ return s.replace("\\", "\\\\").replace("\"", "\\\""); }

    /* ===== Tiny demo: writes MyRunnerConfig.java ===== */
    public static void main(String[] args) throws IOException {
        // Top-level params
        var top = List.of(
            new ParamSpec("chronicleDir", Type.STRING, "./chronicle", false, "chronicle-dir", "cdir"),
            new ParamSpec("mode",         Type.STRING, "stream",      false, "m"),
            new ParamSpec("verbose",      Type.BOOLEAN, "false",      false, "v"),
            new ParamSpec("batchSize",    Type.INT,     "1000",       false, "batch-size", "bs")
        );

        // Subset: amps.*
        var amps = new SubsetSpec(
            "amps", "Amps",
            List.of(
                new ParamSpec("p1", Type.STRING,  null,   true,  "p-1"),
                new ParamSpec("p2", Type.INT,     "2",    false, "p-2"),
                new ParamSpec("p3", Type.BOOLEAN, "true", false, "p-3")
            )
        );

        String src = generate("com.example", "MyRunnerConfig",
                              Visibility.PACKAGE_PRIVATE, top, List.of(amps));
        Files.writeString(Path.of("MyRunnerConfig.java"), src, StandardCharsets.UTF_8);
        System.out.println("Wrote MyRunnerConfig.java");
    }
}
