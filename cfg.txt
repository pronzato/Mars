// AbstractNamespacedConfig.java
// Hand-written base: parsing, alias resolution, list parsers, help scaffolding.
// You keep this file; your generator only emits the concrete subclass.

import java.util.*;

public abstract class AbstractNamespacedConfig<B, C> {

  /* ===== Param & Subset metadata used for help text ===== */

  public enum Type {
    STRING, INT, LONG, DOUBLE, BOOLEAN,
    STRING_LIST, INT_LIST, LONG_LIST, DOUBLE_LIST, BOOLEAN_LIST
  }

  public static final class ParamInfo {
    public final String name;              // canonical field name, e.g. "batchSize"
    public final Type type;
    public final boolean mandatory;        // only enforced if subset is "used" (for subset params)
    public final Object defaultValue;      // already a Java object (String, Number, Boolean, List<?>)
    public final List<String> aliases;     // includes kebab-case etc.

    public ParamInfo(String name, Type type, boolean mandatory, Object defaultValue, List<String> aliases) {
      this.name = name; this.type = type; this.mandatory = mandatory;
      this.defaultValue = defaultValue; this.aliases = aliases == null ? List.of() : List.copyOf(aliases);
    }
  }

  public static final class SubsetInfo {
    public final String prefix;             // CLI prefix, e.g. "amps"
    public final String className;          // public inner class & getter base, e.g. "SourceAmps"
    public final List<ParamInfo> params;    // subset params

    public SubsetInfo(String prefix, String className, List<ParamInfo> params) {
      this.prefix = prefix; this.className = className; this.params = List.copyOf(params);
    }
  }

  /* ===== Hooks the generated subclass must implement ===== */

  /** Make a fresh builder instance. */
  protected abstract B newBuilder();

  /** Build final Config from Builder (should call Builder.validate() inside). */
  protected abstract C build(B builder);

  /** Top-level alias map: canonicalName -> list of accepted keys (camel + kebab + custom). */
  protected abstract Map<String, List<String>> topAliases();

  /** Subset alias map: prefix -> (canonicalFieldName -> list of accepted keys). */
  protected abstract Map<String, Map<String, List<String>>> subsetAliases();

  /** Apply one top-level key/value (value is raw string from CLI) to the given builder. */
  protected abstract void applyTopKV(B builder, String canonicalKey, String rawValue);

  /** Apply one subset key/value: prefix + canonical field name + raw string value. */
  protected abstract void applySubsetKV(B builder, String prefix, String canonicalField, String rawValue);

  /** Top-level params for help text. */
  protected abstract List<ParamInfo> topParamsInfo();

  /** Subsets for help text. */
  protected abstract List<SubsetInfo> subsetsInfo();

  /* ===== Public API the concrete class inherits ===== */

  /** Parse CLI args and produce a Config. Supports: --k=v, --k v, --flag, --no-flag, dotted subset keys, kebabâ†”camel. */
  public final C fromArgs(String[] args) {
    B b = newBuilder();
    Map<String, List<String>> tmap = topAliases();
    Map<String, Map<String, List<String>>> smap = subsetAliases();

    for (int i = 0; i < args.length; i++) {
      String tok = args[i];
      if (tok == null || !tok.startsWith("--")) continue;

      String s = tok.substring(2);
      boolean neg = s.startsWith("no-");
      if (neg) s = s.substring(3);

      String key;
      String val;
      int eq = s.indexOf('=');
      if (eq > 0) {
        key = s.substring(0, eq);
        val = s.substring(eq + 1);
      } else {
        key = s;
        if (i + 1 < args.length && !args[i + 1].startsWith("--")) {
          val = args[++i];
        } else {
          val = neg ? "false" : "true";
        }
      }

      key = toCamelDotted(key);
      int dot = key.indexOf('.');
      if (dot < 0) {
        // top-level
        boolean handled = false;
        for (var e : tmap.entrySet()) {
          if (matches(key, e.getValue())) {
            applyTopKV(b, e.getKey(), val);
            handled = true;
            break;
          }
        }
        // unknown top-level keys are ignored
        continue;
      }

      // subset
      String pref = key.substring(0, dot);
      String field = key.substring(dot + 1);
      Map<String, List<String>> fam = smap.get(pref);
      if (fam == null) continue;
      boolean handledField = false;
      for (var fe : fam.entrySet()) {
        if (matches(toCamel(field), fe.getValue())) {
          applySubsetKV(b, pref, fe.getKey(), val);
          handledField = true;
          break;
        }
      }
      // unknown subset fields are ignored
    }

    return build(b);
  }

  /** Print a friendly help with keys, aliases, types, defaults, and mandatory flags. */
  public final void printHelp() {
    StringBuilder h = new StringBuilder();
    h.append("Options (top-level):\n");
    for (ParamInfo p : topParamsInfo()) {
      h.append("  --").append(toKebab(p.name));
      if (!p.aliases.isEmpty()) h.append("  aliases: ").append(String.join(", ", p.aliases));
      h.append("  type=").append(typeNameForHelp(p.type));
      h.append("  default=").append(String.valueOf(p.defaultValue));
      if (p.mandatory) h.append("  (mandatory)");
      h.append("\n");
    }
    for (SubsetInfo s : subsetsInfo()) {
      h.append("\nSubset ").append(s.className)
       .append(" (CLI: --").append(s.prefix).append(".<field> ...):\n");
      for (ParamInfo p : s.params) {
        h.append("  --").append(s.prefix).append(".").append(toKebab(p.name));
        if (!p.aliases.isEmpty()) h.append("  aliases: ").append(String.join(", ", p.aliases));
        h.append("  type=").append(typeNameForHelp(p.type));
        h.append("  default=").append(String.valueOf(p.defaultValue));
        if (p.mandatory) h.append("  (mandatory when subset is used)");
        h.append("\n");
      }
    }
    System.out.print(h.toString());
  }

  /* ===== Shared helpers (protected so concrete can call if needed) ===== */

  protected static boolean matches(String key, List<String> aliases) {
    if (aliases == null) return false;
    for (String a : aliases) if (a.equals(key)) return true;
    return false;
  }

  protected static String toCamel(String key) {
    if (key.indexOf('-') < 0) return key;
    StringBuilder sb = new StringBuilder(key.length());
    boolean up = false;
    for (char c : key.toCharArray()) {
      if (c == '-') { up = true; continue; }
      sb.append(up ? Character.toUpperCase(c) : c);
      up = false;
    }
    return sb.toString();
  }

  protected static String toCamelDotted(String dotted) {
    String[] parts = dotted.split("\\.");
    for (int i = 0; i < parts.length; i++) parts[i] = toCamel(parts[i]);
    return String.join(".", parts);
  }

  protected static String toKebab(String camel) {
    StringBuilder sb = new StringBuilder(camel.length() + 8);
    for (char c : camel.toCharArray()) {
      if (Character.isUpperCase(c)) sb.append('-').append(Character.toLowerCase(c));
      else sb.append(c);
    }
    return sb.toString();
  }

  protected static String capitalize(String s) {
    if (s == null || s.isEmpty()) return s;
    return Character.toUpperCase(s.charAt(0)) + s.substring(1);
  }

  /* ===== List parsers (comma-separated) ===== */
  protected static List<String>  parseStringList (String s){ return splitMap(s, e -> e); }
  protected static List<Integer> parseIntList    (String s){ return splitMap(s, Integer::parseInt); }
  protected static List<Long>    parseLongList   (String s){ return splitMap(s, Long::parseLong); }
  protected static List<Double>  parseDoubleList (String s){ return splitMap(s, Double::parseDouble); }
  protected static List<Boolean> parseBooleanList(String s){ return splitMap(s, Boolean::parseBoolean); }

  private static <T> List<T> splitMap(String s, java.util.function.Function<String, T> f) {
    if (s == null || s.isBlank()) return List.of();
    String[] a = s.split(",");
    List<T> out = new ArrayList<>(a.length);
    for (String e : a) {
      e = e.trim();
      if (!e.isEmpty()) out.add(f.apply(e));
    }
    return java.util.Collections.unmodifiableList(out);
  }

  protected static String typeNameForHelp(Type t) {
    return switch (t) {
      case STRING -> "string";
      case INT -> "int";
      case LONG -> "long";
      case DOUBLE -> "double";
      case BOOLEAN -> "boolean";
      case STRING_LIST -> "list<string>";
      case INT_LIST -> "list<int>";
      case LONG_LIST -> "list<long>";
      case DOUBLE_LIST -> "list<double>";
      case BOOLEAN_LIST -> "list<boolean>";
    };
  }
}
