// SimpleModelConfigGenerator.java
// Generates a single-file config class using the "simple builder (no functions)" model,
// with Defaults → Config → Builder, sub-properties (groups), aliases, and fromArgs(String[]).
// Java 21+, no external deps.

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

public final class SimpleModelConfigGenerator {

    /* =========================
     * Specs
     * ========================= */
    public enum Type { STRING, INT, LONG, DOUBLE, BOOLEAN }
    public enum Visibility { PUBLIC, PACKAGE_PRIVATE }

    /** Top-level or group field definition. */
    public static final class ParamSpec {
        public final String name;           // canonical key, e.g. "chronicleDir"
        public final Type type;             // STRING/INT/LONG/DOUBLE/BOOLEAN
        public final String defaultValue;   // literal ("stdout","3","true") or null
        public final boolean mandatory;     // must be provided if no default
        public final List<String> aliases;  // alternative keys (kebab allowed)

        public ParamSpec(String name, Type type, String defaultValue, boolean mandatory, List<String> aliases) {
            this.name = Objects.requireNonNull(name);
            this.type = Objects.requireNonNull(type);
            this.defaultValue = defaultValue;
            this.mandatory = mandatory;
            this.aliases = aliases == null ? List.of() : List.copyOf(aliases);
        }
        public ParamSpec(String name, Type type, String defaultValue, boolean mandatory, String... aliases) {
            this(name, type, defaultValue, mandatory, Arrays.asList(aliases));
        }
    }

    /** Repeated group (sub-properties) like "source.<name>.<field>=value". */
    public static final class GroupSpec {
        public final String singularClassName;   // e.g., "Source"
        public final String canonicalPrefix;     // e.g., "source"
        public final List<String> prefixAliases; // e.g., ["src"]
        public final List<ParamSpec> fields;     // params for each named instance

        public GroupSpec(String singularClassName, String canonicalPrefix, List<String> prefixAliases, List<ParamSpec> fields) {
            this.singularClassName = Objects.requireNonNull(singularClassName);
            this.canonicalPrefix   = Objects.requireNonNull(canonicalPrefix);
            this.prefixAliases     = prefixAliases == null ? List.of() : List.copyOf(prefixAliases);
            this.fields            = List.copyOf(fields);
        }
    }

    /* =========================
     * Generator
     * ========================= */
    public static String generate(
            String packageNameOrNull,
            String className,
            Visibility visibility,
            List<ParamSpec> topParams,
            List<GroupSpec> groups
    ) {
        String pkg = (packageNameOrNull == null || packageNameOrNull.isBlank())
                ? "" : "package " + packageNameOrNull + ";\n\n";
        String classVis = (visibility == Visibility.PUBLIC) ? "public " : "";

        StringBuilder sb = new StringBuilder(40_000);
        sb.append(pkg);
        sb.append("// Auto-generated by SimpleModelConfigGenerator\n");
        sb.append("// Single-file config with Defaults, Config, Builder (no functions), groups, aliases, fromArgs(String[])\n");
        sb.append("import java.util.*;\n\n");

        sb.append(classVis).append("final class ").append(className).append(" {\n\n");

        /* ----- DEFAULTS (top-level) ----- */
        sb.append("  // ===== Defaults (top-level) =====\n");
        sb.append("  static final class Defaults {\n");
        for (ParamSpec p : topParams) {
            sb.append("    static final ").append(javaType(p.type)).append(" ").append(p.name)
              .append(" = ").append(defaultLiteral(p)).append(";\n");
        }
        for (GroupSpec g : groups) {
            sb.append("    // Group: ").append(g.canonicalPrefix).append("\n");
            for (ParamSpec p : g.fields) {
                sb.append("    static final ").append(javaType(p.type)).append(" ")
                  .append(g.canonicalPrefix).append("_").append(p.name)
                  .append(" = ").append(defaultLiteral(p)).append(";\n");
            }
        }
        sb.append("  }\n\n");

        /* ----- GROUP CLASSES ----- */
        for (GroupSpec g : groups) {
            sb.append("  // ===== Group: ").append(g.canonicalPrefix).append(" (").append(g.singularClassName).append(") =====\n");
            sb.append("  static final class ").append(g.singularClassName).append(" {\n");
            // group Config
            sb.append("    static final class Config {\n");
            for (ParamSpec p : g.fields) {
                sb.append("      final ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
            }
            sb.append("      private Config(");
            for (int i = 0; i < g.fields.size(); i++) {
                if (i > 0) sb.append(", ");
                ParamSpec p = g.fields.get(i);
                sb.append(javaType(p.type)).append(" ").append(p.name);
            }
            sb.append(") {\n");
            for (ParamSpec p : g.fields) {
                sb.append("        this.").append(p.name).append(" = ").append(p.name).append(";\n");
            }
            sb.append("      }\n");
            sb.append("      @Override public String toString() { return \"").append(g.singularClassName).append(".Config\"; }\n");
            sb.append("    }\n");
            // group Builder (no functions)
            sb.append("    static final class Builder {\n");
            for (ParamSpec p : g.fields) {
                String dv = "Defaults." + g.canonicalPrefix + "_" + p.name;
                if (p.defaultValue == null) {
                    // null for String; zero/false for primitives OK, but we want to detect "not provided" only for String mandatory
                    if (p.type == Type.STRING) {
                        sb.append("      ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
                    } else {
                        sb.append("      ").append(javaType(p.type)).append(" ").append(p.name).append(" = ").append(javaDefault(p.type)).append(";\n");
                    }
                } else {
                    sb.append("      ").append(javaType(p.type)).append(" ").append(p.name).append(" = ").append(dv).append(";\n");
                }
            }
            for (ParamSpec p : g.fields) {
                sb.append("      Builder ").append(p.name).append("(").append(javaType(p.type)).append(" v) { this.")
                  .append(p.name).append(" = v; return this; }\n");
            }
            sb.append("      Config build() {\n");
            for (ParamSpec p : g.fields) {
                if (p.mandatory && p.defaultValue == null) {
                    sb.append("        if (");
                    if (p.type == Type.STRING) {
                        sb.append(p.name).append(" == null || ").append(p.name).append(".isBlank()");
                    } else {
                        sb.append("false"); // primitives always have a value; users decide sentinel if needed
                    }
                    sb.append(") throw new IllegalArgumentException(\"Missing mandatory field: ").append(p.name).append("\");\n");
                }
            }
            sb.append("        return new Config(");
            for (int i = 0; i < g.fields.size(); i++) {
                if (i > 0) sb.append(", ");
                sb.append(g.fields.get(i).name);
            }
            sb.append(");\n");
            sb.append("      }\n");
            sb.append("    }\n");
            // field alias map for the group
            sb.append("    private static Map<String, List<String>> fieldAliasMap() {\n");
            sb.append("      Map<String,List<String>> m = new LinkedHashMap<>();\n");
            for (ParamSpec p : g.fields) {
                sb.append("      m.put(\"").append(p.name).append("\", List.of(");
                List<String> all = new ArrayList<>();
                all.add(p.name);
                all.addAll(p.aliases);
                // also auto-add kebab-case alias for camel names
                String kebab = toKebab(p.name);
                if (!all.contains(kebab)) all.add(kebab);
                for (int i=0;i<all.size();i++) {
                    if (i>0) sb.append(", ");
                    sb.append("\"").append(escape(all.get(i))).append("\"");
                }
                sb.append("));\n");
            }
            sb.append("      return m;\n");
            sb.append("    }\n");
            sb.append("  }\n\n");
        }

        /* ----- TOP-LEVEL CONFIG ----- */
        sb.append("  // ===== Top-level Config =====\n");
        sb.append("  static final class Config {\n");
        for (ParamSpec p : topParams) {
            sb.append("    final ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
        }
        for (GroupSpec g : groups) {
            sb.append("    final Map<String, ").append(g.singularClassName).append(".Config> ").append(g.canonicalPrefix).append("s;\n");
        }
        sb.append("    private Config(");
        {
            boolean first = true;
            for (ParamSpec p : topParams) {
                if (!first) sb.append(", "); first = false;
                sb.append(javaType(p.type)).append(" ").append(p.name);
            }
            for (GroupSpec g : groups) {
                if (!first) sb.append(", "); first = false;
                sb.append("Map<String, ").append(g.singularClassName).append(".Config> ").append(g.canonicalPrefix).append("s");
            }
        }
        sb.append(") {\n");
        for (ParamSpec p : topParams) {
            sb.append("      this.").append(p.name).append(" = ").append(p.name).append(";\n");
        }
        for (GroupSpec g : groups) {
            sb.append("      this.").append(g.canonicalPrefix).append("s = ")
              .append("Collections.unmodifiableMap(new LinkedHashMap<>(").append(g.canonicalPrefix).append("s));\n");
        }
        sb.append("    }\n");
        sb.append("  }\n\n");

        /* ----- BUILDER (no functions) ----- */
        sb.append("  // ===== Builder (no functions) =====\n");
        sb.append("  static final class Builder {\n");
        for (ParamSpec p : topParams) {
            String dv = "Defaults." + p.name;
            if (p.defaultValue == null) {
                if (p.type == Type.STRING) {
                    sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(";\n");
                } else {
                    sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(" = ").append(javaDefault(p.type)).append(";\n");
                }
            } else {
                sb.append("    ").append(javaType(p.type)).append(" ").append(p.name).append(" = ").append(dv).append(";\n");
            }
        }
        for (GroupSpec g : groups) {
            sb.append("    final Map<String, ").append(g.singularClassName).append(".Builder> ")
              .append(g.canonicalPrefix).append("Builders = new LinkedHashMap<>();\n");
        }
        // setters
        for (ParamSpec p : topParams) {
            sb.append("    Builder ").append(p.name).append("(").append(javaType(p.type)).append(" v) { this.")
              .append(p.name).append(" = v; return this; }\n");
        }
        // group accessors (return sub-builder)
        for (GroupSpec g : groups) {
            sb.append("    ").append(g.singularClassName).append(".Builder ").append(g.canonicalPrefix).append("(String name) {\n");
            sb.append("      return ").append(g.canonicalPrefix).append("Builders.computeIfAbsent(name, k -> new ")
              .append(g.singularClassName).append(".Builder());\n");
            sb.append("    }\n");
        }
        // build()
        sb.append("    Config build() {\n");
        // basic top-level validation for mandatory-without-default STRING fields
        for (ParamSpec p : topParams) {
            if (p.mandatory && p.defaultValue == null) {
                sb.append("      if (");
                if (p.type == Type.STRING) {
                    sb.append(p.name).append(" == null || ").append(p.name).append(".isBlank()");
                } else {
                    sb.append("false");
                }
                sb.append(") throw new IllegalArgumentException(\"Missing mandatory parameter: ").append(p.name).append("\");\n");
            }
        }
        for (GroupSpec g : groups) {
            sb.append("      Map<String, ").append(g.singularClassName).append(".Config> _")
              .append(g.canonicalPrefix).append("s = new LinkedHashMap<>();\n");
            sb.append("      for (var e : ").append(g.canonicalPrefix).append("Builders.entrySet()) {\n");
            sb.append("        _").append(g.canonicalPrefix).append("s.put(e.getKey(), e.getValue().build());\n");
            sb.append("      }\n");
        }
        sb.append("      return new Config(");
        {
            boolean first = true;
            for (ParamSpec p : topParams) { if (!first) sb.append(", "); first = false; sb.append(p.name); }
            for (GroupSpec g : groups)    { if (!first) sb.append(", "); first = false; sb.append("_").append(g.canonicalPrefix).append("s"); }
        }
        sb.append(");\n");
        sb.append("    }\n");
        sb.append("  }\n\n");

        sb.append("  static Builder builder() { return new Builder(); }\n\n");

        /* ----- ALIAS MAPS (top-level & prefix) ----- */
        sb.append("  private static Map<String,List<String>> topAliasMap() {\n");
        sb.append("    Map<String,List<String>> m = new LinkedHashMap<>();\n");
        for (ParamSpec p : topParams) {
            List<String> all = new ArrayList<>();
            all.add(p.name);
            all.addAll(p.aliases);
            String kebab = toKebab(p.name);
            if (!all.contains(kebab)) all.add(kebab);
            sb.append("    m.put(\"").append(p.name).append("\", List.of(");
            for (int i=0;i<all.size();i++) { if (i>0) sb.append(", "); sb.append("\"").append(escape(all.get(i))).append("\""); }
            sb.append("));\n");
        }
        sb.append("    return m;\n");
        sb.append("  }\n\n");

        sb.append("  private static Map<String,List<String>> prefixAliasMap() {\n");
        sb.append("    Map<String,List<String>> m = new LinkedHashMap<>();\n");
        for (GroupSpec g : groups) {
            List<String> all = new ArrayList<>();
            all.add(g.canonicalPrefix);
            all.addAll(g.prefixAliases);
            String kebab = toKebab(g.canonicalPrefix);
            if (!all.contains(kebab)) all.add(kebab);
            sb.append("    m.put(\"").append(g.canonicalPrefix).append("\", List.of(");
            for (int i=0;i<all.size();i++) { if (i>0) sb.append(", "); sb.append("\"").append(escape(all.get(i))).append("\""); }
            sb.append("));\n");
        }
        sb.append("    return m;\n");
        sb.append("  }\n\n");

        /* ----- fromArgs(String[]) ----- */
        sb.append("  static Config fromArgs(String[] args) {\n");
        sb.append("    Map<String,String> raw = new LinkedHashMap<>();\n");
        sb.append("    for (String a : args) {\n");
        sb.append("      if (a == null || !a.startsWith(\"-\")) continue;\n");
        sb.append("      String s = a.replaceFirst(\"^-+\", \"\");\n");
        sb.append("      if (s.startsWith(\"no-\")) { raw.put(s.substring(3), \"false\"); continue; }\n");
        sb.append("      int eq = s.indexOf('=');\n");
        sb.append("      if (eq > 0) raw.put(s.substring(0,eq), s.substring(eq+1)); else raw.put(s, \"true\");\n");
        sb.append("    }\n");

        sb.append("    Builder b = builder();\n");
        sb.append("    Map<String,List<String>> tmap = topAliasMap();\n");
        sb.append("    // Top-level overlays\n");
        for (ParamSpec p : topParams) {
            sb.append("    {\n");
            sb.append("      String _v = null;\n");
            sb.append("      var _als = tmap.get(\"").append(p.name).append("\");\n");
            sb.append("      if (_als != null) for (String a : _als) { if (raw.containsKey(a)) { _v = raw.get(a); break; } }\n");
            sb.append("      if (_v != null) {\n");
            switch (p.type) {
                case STRING -> sb.append("        b.").append(p.name).append("(_v);\n");
                case INT    -> sb.append("        b.").append(p.name).append("(Integer.parseInt(_v));\n");
                case LONG   -> sb.append("        b.").append(p.name).append("(Long.parseLong(_v));\n");
                case DOUBLE -> sb.append("        b.").append(p.name).append("(Double.parseDouble(_v));\n");
                case BOOLEAN-> sb.append("        b.").append(p.name).append("(Boolean.parseBoolean(_v));\n");
            }
            sb.append("      }\n");
            sb.append("    }\n");
        }

        // parse groups: prefix.instance.field (aliases on prefix and field)
        sb.append("    Map<String,List<String>> pmap = prefixAliasMap();\n");
        for (GroupSpec g : groups) {
            String gname = g.canonicalPrefix;
            sb.append("    {\n");
            sb.append("      List<String> _prefixes = pmap.get(\"").append(gname).append("\");\n");
            sb.append("      Map<String,List<String>> _fals = ").append(g.singularClassName).append(".fieldAliasMap();\n");
            sb.append("      for (var e : raw.entrySet()) {\n");
            sb.append("        String k = e.getKey(); String v = e.getValue();\n");
            sb.append("        String matched = null;\n");
            sb.append("        for (String p : _prefixes) { if (k.startsWith(p + \".\")) { matched = p; break; } }\n");
            sb.append("        if (matched == null) continue;\n");
            sb.append("        String rest = k.substring(matched.length() + 1); // <name>.<field>\n");
            sb.append("        int dot = rest.indexOf('.'); if (dot <= 0) continue;\n");
            sb.append("        String inst = rest.substring(0, dot);\n");
            sb.append("        String fkey = rest.substring(dot + 1);\n");
            sb.append("        // normalize kebab→camel on fkey quickly\n");
            sb.append("        fkey = toCamel(fkey);\n");
            sb.append("        String canonField = null;\n");
            sb.append("        outer: for (var fe : _fals.entrySet()) {\n");
            sb.append("          for (String a : fe.getValue()) { if (a.equals(fkey)) { canonField = fe.getKey(); break outer; } }\n");
            sb.append("        }\n");
            sb.append("        if (canonField == null) continue;\n");
            sb.append("        var sbld = b.").append(gname).append("(inst);\n");
            // field setter switch
            sb.append("        switch (canonField) {\n");
            for (ParamSpec fp : g.fields) {
                sb.append("          case \"").append(fp.name).append("\": ");
                switch (fp.type) {
                    case STRING -> sb.append("sbld.").append(fp.name).append("(v); break;\n");
                    case INT    -> sb.append("sbld.").append(fp.name).append("(Integer.parseInt(v)); break;\n");
                    case LONG   -> sb.append("sbld.").append(fp.name).append("(Long.parseLong(v)); break;\n");
                    case DOUBLE -> sb.append("sbld.").append(fp.name).append("(Double.parseDouble(v)); break;\n");
                    case BOOLEAN-> sb.append("sbld.").append(fp.name).append("(Boolean.parseBoolean(v)); break;\n");
                }
            }
            sb.append("          default: break;\n");
            sb.append("        }\n");
            sb.append("      }\n");
            sb.append("    }\n");
        }

        sb.append("    return b.build();\n");
        sb.append("  }\n\n");

        /* ----- Helpers embedded in generated class ----- */
        sb.append("  private static String toCamel(String key) {\n");
        sb.append("    if (key.indexOf('-') < 0) return key;\n");
        sb.append("    StringBuilder _sb = new StringBuilder(key.length()); boolean up = false;\n");
        sb.append("    for (char c : key.toCharArray()) { if (c=='-') { up=true; continue; } _sb.append(up?Character.toUpperCase(c):c); up=false; }\n");
        sb.append("    return _sb.toString();\n");
        sb.append("  }\n");

        sb.append("}\n");

        return sb.toString();
    }

    /* =========================
     * Codegen helpers (outside the generated class)
     * ========================= */
    private static String javaType(Type t) {
        return switch (t) {
            case STRING -> "String";
            case INT    -> "int";
            case LONG   -> "long";
            case DOUBLE -> "double";
            case BOOLEAN-> "boolean";
        };
    }
    private static String javaDefault(Type t) {
        return switch (t) {
            case STRING -> "null";
            case INT    -> "0";
            case LONG   -> "0L";
            case DOUBLE -> "0.0d";
            case BOOLEAN-> "false";
        };
    }
    private static String defaultLiteral(ParamSpec p) {
        if (p.defaultValue == null) return javaDefault(p.type);
        String dv = p.defaultValue;
        return switch (p.type) {
            case STRING -> "\"" + escape(dv) + "\"";
            case INT    -> dv;
            case LONG   -> dv.endsWith("L") ? dv : dv + "L";
            case DOUBLE -> dv.contains(".") ? dv : dv + ".0";
            case BOOLEAN-> dv.toLowerCase(Locale.ROOT);
        };
    }
    private static String escape(String s) {
        return s.replace("\\", "\\\\").replace("\"", "\\\"");
    }
    private static String toKebab(String camel) {
        StringBuilder sb = new StringBuilder(camel.length() + 8);
        for (char c : camel.toCharArray()) {
            if (Character.isUpperCase(c)) { sb.append('-').append(Character.toLowerCase(c)); }
            else sb.append(c);
        }
        return sb.toString();
    }

    /* =========================
     * Tiny demo: writes MyRunnerConfig.java
     * ========================= */
    public static void main(String[] args) throws IOException {
        // Top-level params
        var top = List.of(
            new ParamSpec("chronicleDir", Type.STRING, "./chronicle", false, "chronicle-dir", "cdir"),
            new ParamSpec("mode",         Type.STRING, "stream",      false, "m"),
            new ParamSpec("verbose",      Type.BOOLEAN, "false",      false, "v")
        );

        // Group "source"
        var sourceFields = List.of(
            new ParamSpec("uri",       Type.STRING,  null,   true,  "u"),
            new ParamSpec("batchSize", Type.INT,     "1000", false, "batch-size", "bs"),
            new ParamSpec("enabled",   Type.BOOLEAN, "true", false, "en")
        );
        var sources = new GroupSpec("Source", "source", List.of("src"), sourceFields);

        String src = generate(
            "com.example",
            "MyRunnerConfig",
            Visibility.PACKAGE_PRIVATE,   // change to PUBLIC if you want a public class
            top,
            List.of(sources)
        );

        Path out = Path.of("MyRunnerConfig.java");
        Files.writeString(out, src, StandardCharsets.UTF_8);
        System.out.println("Wrote " + out.toAbsolutePath());
    }
}
