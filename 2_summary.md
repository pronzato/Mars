h1. Fabric Tapestry â€“ Current UI Components

h2. 1. Data Tables
* Snapshot tables (REST)
* Live-streaming tables (Flight SQL â†’ WebSocket streaming)
* Local dataset tables (DuckDB/Parquet via LOCAL_DATASET backend)
* Full dark-theme styling with elevated surfaces

h2. 2. Column Features
* Sorting (ASC/DESC)
* Filtering (dynamic filter row with fabric-input widgets)
* Column formatting (dates, decimals, CSS classes)
* Type-aware rendering
* Visibility and customization via metadata

h2. 3. Filter Row
Tapestry auto-generates a second header row containing input fields for any column marked filterable.

h2. 4. Toolbar Actions
* Table- or row-level actions
* Action types supported:
** *JAVA* (inline server handler)
** *HTTP* (REST calls)
** *FLOW* (trigger Fabric Flow runs)
** *AMPS* (publish messages)
* Toolbar is automatically rendered based on UiActionDef.

h2. 5. Row Selection
* Multi-row or single-row selection
* Selection-aware actions

h2. 6. Entitlements
* Row filtering (via PDP rowFilterSql)
* Column masking
* Applied consistently across both execution backends

h2. 7. Live Subscription Layer
* SERVICE mode: Full Flight SQL subscription â†’ TableDelta streaming
* LOCAL mode: Snapshot-only with safe fallback

h2. 8. Autogenerated UI
Tapestry exposes:
* /api/datasets
* /api/datasets/{id}/schema
* /api/datasets/{id}/autogen-html

These produce complete HTML skeleton dashboards from metadata.

h2. 9. Unified Tapestry Theme
* Dark palette
* Fabric-style header bar and nav menu
* fabric-surface, fabric-table, fabric-frame, fabric-section, fabric-toolbar
* Mode pill:
** â€œLOCAL DATASET MODEâ€
** â€œSERVICE MODEâ€

h2. 10. Dual Execution Backends
* *LOCAL_DATASET* (fast DuckDB/Parquet for development)
* *FLIGHT_SQL_SERVICE* (curated enterprise data services)

Switching modes:
{code}
-Dtapestry.sourceMode=local
-Dtapestry.sourceMode=service
{code}


















What UI Components Clients Can Build Today in Fabric Tapestry

Fabric Tapestry, as it stands right now, provides a powerful set of UI building blocks that clients can use to rapidly build table-driven, live-updating, entitlement-aware dashboards.
Below is the complete list of UI components that exist today.

ğŸ§µ 1. Live / Static Data Tables

Tapestryâ€™s primary component is a data table backed by a UiTableView + UiDataView definition.

Clients can build:

âœ” Snapshot tables

Loaded via REST: /api/ui/table/{id}/snapshot

Include:

columns

rows

pagination info

applied filters/sorts

âœ” Live-updating tables (if using SERVICE mode)

Real-time deltas streamed from Flight SQL subscriptions

UPSERT & DELETE row operations applied in-browser

Perfect for positions, orders, prices, risk, PnL, etc.

âœ” Local dataset tables (LOCAL mode)

Identical UI

Executed via DuckDB over parquet/S3

Ideal for development without services

ğŸªŸ 2. Column Definitions with Rich Behavior

Each column in a UiTableView supports:

âœ” Sorting (ascending/descending)
âœ” Filtering (text filters in filter row)
âœ” Type hints (STRING, DOUBLE, BOOLEAN, TIMESTAMP, etc.)
âœ” Formatting (decimal, datetime, custom CSS classes)
âœ” Visibility & reordering (via configuration)

This creates a highly interactive developer-friendly data grid.

ğŸ” 3. Filter Row (dynamic inputs)

Automatically shows a second header row with input fields for columns marked as filterable:

Instant incremental filtering

Generates query params like:
filter_symbol=AAPL&filter_book=EQUITY_SWAPS

Works in both LOCAL and SERVICE modes

This is extremely useful for quants exploring datasets.

â†• 4. Sortable Headers

Clients simply click column headers to toggle:

no sort

ascending

descending

Tapestry automatically:

updates the query params

regenerates the snapshot

updates UI to reflect active sort state

ğŸ› 5. Toolbar Actions

Based on UiActionDef, Tapestry automatically renders per-table or per-row actions:

âœ” Table-wide actions

Example:

Revalue book

Refresh dataset

Publish snapshot

Recompute metrics

âœ” Row-level actions (coming from row selection)

Example:

Cancel order

Drill-down on a counterparty

Trigger a model run for a selected record

Actions support multiple backend types:

JAVA function (server-side)

HTTP call

Flow invocation

AMPS publish

Flight SQL Action (future)

ğŸ§â€â™‚ï¸ğŸ§â€â™€ï¸ 6. Row Selection

Built-in row selection (single or multi-select):

Enables multi-row actions

Highlights selected rows

Allows quants to run actions on filtered subsets

ğŸ” 7. Entitlements-Aware UI

Tapestry already integrates with your PDP:

âœ” Row-level filtering

Rows a user is not entitled to are removed in the backend.

âœ” Column masking

Sensitive values are null/masked dynamically.

âœ” Consistent between LOCAL and SERVICE modes

Even local dataset queries apply the PDP, preserving security.

ğŸ”„ 8. Live Streaming Indicators

(Built into the behavior, not yet surfaced visually.)

SERVICE mode dashboards auto-open WebSockets

Deltas update the table in real time

LOCAL mode warns gracefully (snapshot-only)

ğŸ¨ 9. Unified Dark Theme & Header Layout

The UI framework provides:

Global header bar

NAV menu

Studio-inspired dark theme

Surface containers (fabric-surface)

Page titles + subtitles

Elevated cards with shadows

Table wrapper with scroll, sticky headers

Tapestry Mode Pill:

â€œLOCAL DATASET MODEâ€

â€œSERVICE MODEâ€

All screens built in Tapestry share this style with zero additional coding.

ğŸ›  10. Auto-Generated HTML Skeletons from Metadata

Via:

/api/datasets

/api/datasets/{id}/schema

/api/datasets/{id}/autogen-html

This gives clients:

âœ” Instant HTML templates
âœ” Ready-to-run screens
âœ” Copilot-friendly outputs

This reduces dashboard development time dramatically.

ğŸŒ 11. Routing + Screen Layout System

With TapestryRoutes classes, clients can define:

Pages

Sections

Titles + subtitles

Surfaces

Embedded tables via data-table-id

This is extremely lightweight and easy to extend.

ğŸ§© 12. Dual Backend Execution Architecture

Clients can choose backend per app OR per dataset:

LOCAL_DATASET (DuckDB / Parquet)
â†’ fastest development path

FLIGHT_SQL_SERVICE
â†’ curated, production-grade data services

Switching mode is:

-Dtapestry.sourceMode=local
-Dtapestry.sourceMode=service


This is a powerful capability unique to Tapestry.

ğŸ“ˆ Summary â€“ What clients can build TODAY

Using Tapestry, clients can build:

âœ… Full dashboards composed of:

Interactive, filterable, sortable, paginated data tables

Real-time streaming tables (SERVICE mode)

Tables with entitlement filtering & masking

Action toolbars (table/row level)

Selection-enabled workflows

Auto-generated UI from dataset metadata

Modern dark-themed screens with standardized layout

Tapestry provides:

A live grid engine

Action system

Backend abstraction (local vs service)

Security integration

UI layout components

Auto-layout HTML generator

WebSocket session wiring

Clients never need to:

Hand-write REST clients

Bind WebSockets manually

Build table HTML

Re-implement sorting/filter logic

Deal with entitlement SQL manually

Care whether data is local or service-backed

If you'd like, I can also prepare:

A glossy â€œselling pointâ€ deck summary

A confluence page describing Tapestryâ€™s UI primitives

A roadmap of the next set of components we should build:
charts, forms, dashboards layouts, drilldowns, linked views, etc.
